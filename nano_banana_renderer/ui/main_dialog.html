<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NanoBanana Renderer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0a0a0a;
      color: #e0e0e0;
      height: 100vh;
      display: flex;
      overflow: hidden;
      font-size: 12px;
    }

    /* 초기 로딩 화면 */
    .app-loader {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #0a0a0a;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      transition: opacity 0.5s, visibility 0.5s;
    }

    .app-loader.hidden {
      opacity: 0;
      visibility: hidden;
    }

    .app-loader-logo {
      font-size: 32px;
      font-weight: 700;
      color: #fff;
      margin-bottom: 24px;
      letter-spacing: -1px;
    }

    .app-loader-logo span {
      color: #ffe033;
    }

    .app-loader-spinner {
      width: 48px;
      height: 48px;
      border: 3px solid #222;
      border-top-color: #ffe033;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }

    .app-loader-text {
      color: #666;
      font-size: 13px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* 좌측 아이콘 메뉴바 */
    .icon-menu {
      width: 48px;
      background: #0a0a0a;
      border-right: 1px solid #333;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 12px 0;
      flex-shrink: 0;
    }

    .icon-menu-item {
      width: 36px;
      height: 36px;
      background: transparent;
      border: none;
      color: #666;
      cursor: pointer;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      margin-bottom: 4px;
    }

    .icon-menu-item:hover {
      background: #1a1a1a;
      color: #ccc;
    }

    .icon-menu-item.active {
      background: #0066ff;
      color: #fff;
    }

    .icon-menu-item svg {
      width: 20px;
      height: 20px;
    }

    .icon-menu-spacer {
      flex: 1;
    }

    .icon-menu-divider {
      width: 24px;
      height: 1px;
      background: #333;
      margin: 8px 0;
    }

    /* 좌측 컨트롤 패널 */
    .sidebar {
      width: 200px;
      background: #141414;
      border-right: 1px solid #333;
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
    }

    .sidebar-header {
      padding: 16px;
      border-bottom: 1px solid #333;
    }

    .logo {
      font-size: 13px;
      font-weight: 600;
      color: #fff;
    }

    .sidebar-content {
      flex: 1;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      overflow-y: auto;
    }

    .control-section {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .section-label {
      font-size: 10px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .segmented {
      display: flex;
      background: #0a0a0a;
      border-radius: 6px;
      padding: 3px;
      border: 1px solid #333;
    }

    /* 커스텀 드롭다운 */
    .custom-dropdown {
      position: relative;
      width: 100%;
    }

    .dropdown-selected {
      width: 100%;
      padding: 8px 10px;
      background: #0a0a0a;
      border: 1px solid #333;
      border-radius: 6px;
      color: #ccc;
      font-size: 11px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-sizing: border-box;
    }

    .dropdown-selected:hover {
      border-color: #555;
    }

    .dropdown-arrow {
      width: 0;
      height: 0;
      border-left: 4px solid transparent;
      border-right: 4px solid transparent;
      border-top: 4px solid #888;
      transition: transform 0.2s;
    }

    .custom-dropdown.open .dropdown-arrow {
      transform: rotate(180deg);
    }

    .dropdown-menu {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 6px;
      margin-top: 4px;
      max-height: 250px;
      overflow-y: auto;
      z-index: 1000;
      display: none;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
    }

    .custom-dropdown.open .dropdown-menu {
      display: block;
    }

    .dropdown-group-label {
      padding: 8px 10px 4px;
      font-size: 10px;
      color: #666;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .dropdown-item {
      padding: 8px 10px;
      font-size: 11px;
      color: #ccc;
      cursor: pointer;
      transition: background 0.15s;
    }

    .dropdown-item:hover {
      background: #2a2a2a;
    }

    .dropdown-item.selected {
      background: #0066ff;
      color: #fff;
    }

    .dropdown-item-desc {
      font-size: 9px;
      color: #666;
      margin-top: 2px;
    }

    .seg-btn {
      flex: 1;
      padding: 8px 4px;
      background: transparent;
      border: none;
      color: #666;
      font-size: 11px;
      font-weight: 500;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.15s;
    }

    .seg-btn:hover {
      color: #aaa;
    }

    .seg-btn.active {
      background: #333;
      color: #fff;
    }

    .sidebar-actions {
      padding: 16px;
      border-top: 1px solid #333;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .btn {
      height: 36px;
      padding: 0 16px;
      border: none;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .btn-primary {
      background: #0066ff;
      color: #fff;
    }

    .btn-primary:hover {
      background: #0055dd;
    }

    .btn-primary:disabled {
      background: #222;
      color: #555;
      cursor: not-allowed;
    }

    .btn-secondary {
      background: #2a2a2a;
      color: #ccc;
    }

    .btn-secondary:hover {
      background: #333;
    }

    .btn-secondary:disabled {
      background: #222;
      color: #555;
      cursor: not-allowed;
    }

    .sidebar-footer {
      padding: 12px 16px;
      border-top: 1px solid #333;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .api-key-section {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .api-key-label {
      font-size: 10px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .api-key-input-row {
      display: flex;
      gap: 4px;
    }

    .api-key-input {
      flex: 1;
      padding: 6px 8px;
      background: #0a0a0a;
      border: 1px solid #333;
      border-radius: 4px;
      color: #ccc;
      font-size: 11px;
      outline: none;
    }

    .api-key-input:focus {
      border-color: #0066ff;
    }

    .api-key-btn {
      padding: 0 10px;
      background: #0066ff;
      border: none;
      border-radius: 4px;
      color: #fff;
      font-size: 12px;
      cursor: pointer;
    }

    .api-key-btn:hover {
      background: #0055dd;
    }

    .status-indicator {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 10px;
      color: #666;
    }

    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #ff3b30;
    }

    .status-dot.connected {
      background: #30d158;
    }

    .icon-btn {
      width: 28px;
      height: 28px;
      background: transparent;
      border: none;
      color: #666;
      cursor: pointer;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
    }

    .icon-btn:hover {
      background: #333;
      color: #fff;
    }

    .icon-btn svg {
      width: 14px;
      height: 14px;
    }

    /* 우측 이미지 영역 */
    .main-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #0a0a0a;
      min-width: 0;
    }

    /* 설정 화면 */
    .settings-main-area {
      justify-content: center;
      align-items: center;
    }

    .settings-container {
      width: 400px;
      background: #1a1a1a;
      border-radius: 12px;
      border: 1px solid #333;
      overflow: hidden;
    }

    .settings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      border-bottom: 1px solid #333;
    }

    .settings-header h2 {
      font-size: 16px;
      font-weight: 600;
      color: #fff;
      margin: 0;
    }

    .settings-close-btn {
      width: 28px;
      height: 28px;
      background: transparent;
      border: none;
      color: #888;
      font-size: 16px;
      cursor: pointer;
      border-radius: 4px;
    }

    .settings-close-btn:hover {
      background: #333;
      color: #fff;
    }

    .settings-content {
      padding: 20px;
    }

    .settings-section {
      margin-bottom: 20px;
    }

    .settings-label {
      display: block;
      font-size: 12px;
      font-weight: 500;
      color: #ccc;
      margin-bottom: 8px;
    }

    .settings-input-row {
      display: flex;
      gap: 8px;
    }

    .settings-input {
      flex: 1;
      padding: 10px 12px;
      background: #0a0a0a;
      border: 1px solid #333;
      border-radius: 6px;
      color: #fff;
      font-size: 13px;
      outline: none;
    }

    .settings-input:focus {
      border-color: #0066ff;
    }

    .settings-toggle-btn {
      padding: 0 12px;
      background: #2a2a2a;
      border: 1px solid #333;
      border-radius: 6px;
      color: #ccc;
      cursor: pointer;
    }

    .settings-toggle-btn:hover {
      background: #333;
    }

    .settings-help {
      font-size: 11px;
      color: #666;
      margin-top: 8px;
    }

    .settings-help a {
      color: #0066ff;
      text-decoration: none;
    }

    .settings-help a:hover {
      text-decoration: underline;
    }

    .settings-status {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 12px;
      background: #0a0a0a;
      border-radius: 6px;
      margin-bottom: 10px;
    }

    .settings-status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #666;
    }

    .settings-status-dot.success {
      background: #34c759;
    }

    .settings-status-dot.error {
      background: #ff3b30;
    }

    .settings-status-dot.testing {
      background: #ff9500;
      animation: pulse 1s infinite;
    }

    .settings-btn {
      padding: 10px 16px;
      background: #2a2a2a;
      border: 1px solid #333;
      border-radius: 6px;
      color: #ccc;
      font-size: 12px;
      cursor: pointer;
    }

    .settings-btn:hover {
      background: #333;
      color: #fff;
    }

    .settings-btn-primary {
      background: #0066ff;
      border-color: #0066ff;
      color: #fff;
    }

    .settings-btn-primary:hover {
      background: #0055dd;
    }

    .settings-actions {
      margin-top: 20px;
      text-align: right;
    }

    .image-container {
      flex: 1;
      display: flex;
      gap: 1px;
      background: #333;
      min-height: 0;
    }

    .image-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #111;
      min-width: 0;
      cursor: pointer;
      border: 2px solid transparent;
      transition: border-color 0.15s;
    }

    .image-panel.selected {
      border-color: #0066ff;
    }

    .image-panel.selected .panel-label {
      background: #0066ff;
      color: #fff;
    }

    .panel-label {
      height: 24px;
      padding: 0 12px;
      background: #1a1a1a;
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 10px;
      color: #555;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      flex-shrink: 0;
    }

    .panel-label span {
      flex: 1;
    }

    .panel-expand-btn {
      width: 20px;
      height: 20px;
      background: transparent;
      border: none;
      color: #555;
      cursor: pointer;
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
    }

    .panel-expand-btn:hover {
      background: #333;
      color: #fff;
    }

    .panel-expand-btn svg {
      width: 12px;
      height: 12px;
    }

    .panel-regenerate-btn {
      width: 20px;
      height: 20px;
      background: #0066ff;
      border: none;
      color: #fff;
      cursor: pointer;
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      margin-right: 4px;
    }

    .panel-regenerate-btn:hover {
      background: #0055dd;
    }

    .panel-regenerate-btn.hidden {
      display: none;
    }

    .panel-regenerate-btn svg {
      width: 12px;
      height: 12px;
    }

    .panel-close-btn {
      width: 20px;
      height: 20px;
      background: transparent;
      border: none;
      color: #666;
      cursor: pointer;
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      margin-left: auto;
      margin-right: 4px;
    }

    .panel-close-btn:hover {
      background: #ff3b30;
      color: #fff;
    }

    .panel-close-btn svg {
      width: 12px;
      height: 12px;
    }

    .panel-guide-btn {
      width: 20px;
      height: 20px;
      background: transparent;
      border: none;
      color: #555;
      cursor: pointer;
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      margin-right: 4px;
    }

    .panel-guide-btn:hover {
      background: #333;
      color: #fff;
    }

    .panel-guide-btn.active {
      background: #0066ff;
      color: #fff;
    }

    .panel-guide-btn svg {
      width: 12px;
      height: 12px;
    }

    /* 프롬프트 영역 */
    .prompt-area {
      height: 200px;
      min-height: 180px;
      background: #111;
      border-top: 1px solid #333;
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
    }

    .prompt-header {
      display: flex;
      align-items: center;
      background: #0a0a0a;
      border-bottom: 1px solid #333;
      flex-shrink: 0;
    }

    .prompt-tabs {
      display: flex;
      flex: 1;
    }

    .prompt-auto-btn {
      height: 28px;
      padding: 0 12px;
      margin-right: 8px;
      background: linear-gradient(135deg, #6b5ce7, #8b5cf6);
      border: none;
      border-radius: 4px;
      color: #fff;
      font-size: 10px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 4px;
      transition: all 0.2s;
    }

    .prompt-auto-btn:hover {
      background: linear-gradient(135deg, #7c6ef0, #9d6fff);
      transform: scale(1.02);
    }

    .prompt-auto-btn:disabled {
      background: #333;
      color: #666;
      cursor: not-allowed;
      transform: none;
    }

    .prompt-auto-btn.loading {
      background: #444;
      pointer-events: none;
    }

    .prompt-auto-btn svg {
      width: 14px;
      height: 14px;
    }

    .prompt-auto-btn svg.spin {
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .prompt-tab {
      flex: 1;
      padding: 8px 12px;
      background: transparent;
      border: none;
      color: #666;
      font-size: 11px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
      border-bottom: 2px solid transparent;
    }

    .prompt-tab:hover {
      color: #aaa;
      background: #1a1a1a;
    }

    .prompt-tab.active {
      color: #fff;
      border-bottom-color: #0066ff;
      background: #1a1a1a;
    }

    .prompt-tab.negative {
      color: #ff6b6b;
    }

    .prompt-tab.negative.active {
      border-bottom-color: #ff6b6b;
    }

    .prompt-content {
      flex: 1;
      display: none;
      padding: 8px 10px;
      min-height: 0;
    }

    .prompt-content.active {
      display: flex;
      flex-direction: column;
    }

    .prompt-area textarea {
      flex: 1;
      width: 100%;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 6px;
      padding: 10px 12px;
      color: #e0e0e0;
      font-size: 11px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      resize: none;
      outline: none;
      overflow-y: auto;
      line-height: 1.5;
    }

    .prompt-area textarea.negative {
      color: #ff9999;
    }

    .prompt-area textarea::-webkit-scrollbar {
      width: 8px;
    }

    .prompt-area textarea::-webkit-scrollbar-track {
      background: #1a1a1a;
      border-radius: 4px;
    }

    .prompt-area textarea::-webkit-scrollbar-thumb {
      background: #444;
      border-radius: 4px;
    }

    .prompt-area textarea::-webkit-scrollbar-thumb:hover {
      background: #555;
    }

    .prompt-area textarea:focus {
      border-color: #0066ff;
      background: #1e1e1e;
    }

    .prompt-area textarea.negative:focus {
      border-color: #ff6b6b;
    }

    .prompt-area textarea::placeholder {
      color: #555;
    }

    .prompt-area textarea:disabled {
      background: #141414;
      color: #666;
      cursor: default;
    }

    /* 프롬프트 입력 + 생성 버튼 래퍼 */
    .prompt-input-wrapper {
      display: flex;
      gap: 8px;
      flex: 1;
      min-height: 0;
    }

    .prompt-input-wrapper textarea {
      flex: 1;
    }

    .prompt-generate-btn {
      width: 44px;
      height: 44px;
      min-width: 44px;
      background: linear-gradient(135deg, #0066ff, #0044cc);
      border: none;
      color: #fff;
      cursor: pointer;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      flex-shrink: 0;
    }

    .prompt-generate-btn:hover {
      background: linear-gradient(135deg, #0077ff, #0055dd);
      transform: scale(1.02);
    }

    .prompt-generate-btn:active {
      transform: scale(0.98);
    }

    .prompt-generate-btn:disabled {
      background: #333;
      cursor: not-allowed;
      opacity: 0.5;
    }

    .prompt-generate-btn svg {
      width: 20px;
      height: 20px;
    }

    .prompt-generate-btn.hidden {
      display: none;
    }

    /* 프롬프트 버튼 그룹 */
    .prompt-btn-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
      flex-shrink: 0;
    }

    .prompt-attach-btn {
      width: 44px;
      height: 44px;
      background: #2a2a2a;
      border: 1px solid #444;
      color: #ccc;
      cursor: pointer;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      flex-shrink: 0;
    }

    .prompt-attach-btn:hover {
      background: #3a3a3a;
      border-color: #0066ff;
      color: #fff;
    }

    .prompt-attach-btn:disabled {
      background: #1a1a1a;
      border-color: #333;
      color: #555;
      cursor: not-allowed;
    }

    .prompt-attach-btn svg {
      width: 20px;
      height: 20px;
    }

    .prompt-attach-btn.has-image {
      background: #0066ff20;
      border-color: #0066ff;
      color: #0066ff;
    }

    /* 가이드 오버레이 */
    .guide-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 5;
      overflow: hidden;
    }

    .guide-overlay.hidden {
      display: none;
    }

    /* 그리드 캔버스 */
    .guide-grid-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
    }

    /* 그리드 슬라이더 컨트롤 */
    .guide-controls {
      position: absolute;
      bottom: 8px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      padding: 6px 12px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      gap: 8px;
      pointer-events: auto;
      z-index: 10;
    }

    .guide-controls.hidden {
      display: none;
    }

    .guide-controls label {
      font-size: 10px;
      color: #aaa;
    }

    .guide-slider {
      width: 100px;
      height: 4px;
      -webkit-appearance: none;
      background: #444;
      border-radius: 2px;
      outline: none;
    }

    .guide-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 12px;
      height: 12px;
      background: #0066ff;
      border-radius: 50%;
      cursor: pointer;
    }

    .guide-value {
      font-size: 10px;
      color: #fff;
      min-width: 35px;
    }

    .guide-lock-btn {
      width: 24px;
      height: 24px;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      color: #aaa;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-left: 4px;
    }

    .guide-lock-btn:hover {
      background: #444;
      color: #fff;
    }

    .guide-lock-btn.locked {
      background: #0066ff;
      border-color: #0066ff;
      color: #fff;
    }

    .guide-lock-btn svg {
      width: 12px;
      height: 12px;
    }

    .guide-controls.locked .guide-slider {
      opacity: 0.3;
      pointer-events: none;
    }

    .guide-zoom-slider {
      width: 80px;
      height: 4px;
      -webkit-appearance: none;
      background: #444;
      border-radius: 2px;
      outline: none;
      margin-left: 8px;
    }

    .guide-zoom-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 12px;
      height: 12px;
      background: #ff6600;
      border-radius: 50%;
      cursor: pointer;
    }

    .image-zoom-container {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .image-zoom-wrapper {
      position: relative;
      transform-origin: center center;
    }

    .image-zoom-wrapper img {
      display: block;
      max-width: none;
      max-height: none;
    }

    .image-zoom-wrapper canvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }

    .image-panel.hidden {
      display: none !important;
    }

    .image-panel.fullscreen {
      flex: 1 1 100% !important;
      max-width: 100% !important;
    }

    .panel-content {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      background: #0d0d0d;
    }

    .panel-content img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      user-select: none;
      -webkit-user-drag: none;
      pointer-events: none;
    }

    .empty-state {
      color: #333;
      font-size: 11px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .auto-prompt-loading,
    .auto-prompt-error {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }

    .auto-prompt-loading .loading-spinner {
      width: 48px;
      height: 48px;
      border: 3px solid #333;
      border-top-color: #0066ff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    .auto-prompt-loading .loading-status {
      color: #fff;
      font-size: 14px;
      font-weight: 500;
    }

    .auto-prompt-loading .loading-detail {
      color: #888;
      font-size: 12px;
    }

    /* 프롬프트 생성 프로그레스 바 */
    .prompt-progress-container {
      width: 200px;
      height: 4px;
      background: #333;
      border-radius: 2px;
      margin-top: 12px;
      overflow: hidden;
    }

    .prompt-progress-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #0066ff, #00aaff);
      border-radius: 2px;
      transition: width 0.3s ease;
    }

    .prompt-progress-text {
      font-size: 11px;
      color: #888;
      margin-top: 6px;
    }

    /* Status Bar */
    .status-bar {
      height: 24px;
      background: #141414;
      border-top: 1px solid #333;
      padding: 0 12px;
      display: flex;
      align-items: center;
      font-size: 10px;
      color: #555;
      flex-shrink: 0;
    }


    /* Loading */
    .loading-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.92);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    .loading-overlay.hidden {
      display: none;
    }

    .loading-spinner {
      position: relative;
      width: 56px;
      height: 56px;
    }

    .loading-spinner::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.1);
    }

    .loading-spinner::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 50%;
      border: 2px solid transparent;
      border-top-color: #fff;
      animation: spinner-rotate 1s cubic-bezier(0.5, 0, 0.5, 1) infinite;
    }

    @keyframes spinner-rotate {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .loading-text {
      margin-top: 24px;
      color: #fff;
      font-size: 13px;
      font-weight: 500;
      letter-spacing: 0.3px;
    }

    .loading-subtext {
      margin-top: 8px;
      color: #555;
      font-size: 11px;
    }

    .loading-progress {
      margin-top: 20px;
      width: 160px;
      height: 3px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
      overflow: hidden;
    }

    .loading-progress-bar {
      height: 100%;
      background: #fff;
      border-radius: 2px;
      transition: width 0.3s ease;
      width: 0%;
    }

    /* Style Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal-overlay.hidden {
      display: none;
    }

    .modal-content {
      background: #1a1a1a;
      border-radius: 12px;
      width: 480px;
      max-width: 90%;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      border: 1px solid #333;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      border-bottom: 1px solid #333;
    }

    .modal-header h3 {
      font-size: 14px;
      font-weight: 600;
      color: #fff;
      margin: 0;
    }

    .modal-close {
      background: none;
      border: none;
      color: #666;
      font-size: 20px;
      cursor: pointer;
      padding: 0;
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
    }

    .modal-close:hover {
      background: #333;
      color: #fff;
    }

    .modal-body {
      padding: 20px;
    }

    .style-presets {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 16px;
      align-items: center;
    }

    .preset-label {
      font-size: 12px;
      color: #888;
      margin-right: 4px;
    }

    .style-preset-btn {
      padding: 6px 12px;
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 16px;
      color: #ccc;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .style-preset-btn:hover {
      background: #333;
      border-color: #666;
      color: #fff;
    }

    .style-preset-btn.active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-color: transparent;
      color: #fff;
    }

    .style-input-group {
      margin-bottom: 12px;
    }

    .style-input-group label {
      display: block;
      font-size: 12px;
      color: #aaa;
      margin-bottom: 8px;
    }

    .style-input-group textarea {
      width: 100%;
      height: 80px;
      padding: 12px;
      background: #111;
      border: 1px solid #333;
      border-radius: 8px;
      color: #fff;
      font-size: 13px;
      resize: none;
      font-family: inherit;
    }

    .style-input-group textarea:focus {
      outline: none;
      border-color: #667eea;
    }

    .style-input-group textarea::placeholder {
      color: #555;
    }

    .style-help-text {
      font-size: 11px;
      color: #666;
      margin: 0;
    }

    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      padding: 16px 20px;
      border-top: 1px solid #333;
    }

    .modal-footer .btn {
      padding: 8px 20px;
      font-size: 12px;
    }

    .loading-progress-bar.indeterminate {
      animation: progress-indeterminate 1.5s ease-in-out infinite;
    }

    @keyframes progress-indeterminate {
      0% { width: 0%; margin-left: 0%; }
      50% { width: 40%; margin-left: 30%; }
      100% { width: 0%; margin-left: 100%; }
    }

    .loading-percent {
      font-weight: 600;
      color: #0066ff;
    }

    /* Camera Controls */
    .camera-controls {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .camera-move {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
    }

    .move-row {
      display: flex;
      gap: 2px;
    }

    .camera-height, .camera-rotate {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .cam-btn {
      width: 28px;
      height: 28px;
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 4px;
      color: #ccc;
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.1s;
    }

    .cam-btn:hover {
      background: #444;
      color: #fff;
    }

    .cam-btn:active {
      background: #0066ff;
    }

    .cam-btn.small {
      width: 24px;
      height: 24px;
      font-size: 10px;
    }

    .btn-mirror {
      width: 100%;
      height: 32px;
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 6px;
      color: #ccc;
      font-size: 11px;
      font-weight: 500;
      cursor: pointer;
      margin-bottom: 8px;
      transition: all 0.15s;
    }

    .btn-mirror:hover {
      background: #444;
    }

    .btn-mirror.active {
      background: #0066ff;
      border-color: #0066ff;
      color: #fff;
    }

    .camera-btns-row {
      display: flex;
      gap: 6px;
      margin-bottom: 8px;
    }

    .camera-btns-row .btn-mirror {
      flex: 1;
      margin-bottom: 0;
    }

    .btn-2point {
      width: 40px;
      height: 32px;
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 6px;
      color: #ccc;
      cursor: pointer;
      transition: all 0.15s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .btn-2point svg {
      width: 16px;
      height: 16px;
    }

    .btn-2point:hover {
      background: #0066ff;
      border-color: #0066ff;
      color: #fff;
    }

    .cam-btn.wasd {
      font-weight: 600;
      font-size: 11px;
    }

    .cam-btn.active-key {
      background: #0066ff;
      border-color: #0066ff;
      color: #fff;
    }

    .keyboard-hint {
      font-size: 9px;
      color: #555;
      text-align: center;
      margin-top: 6px;
    }

    /* ========================================
       Mix Mode Styles
    ======================================== */

    /* Mix 모드 패널 */
    .mix-mode-panel {
      display: none;
      width: 220px;
      background: #141414;
      border-right: 1px solid #333;
      flex-direction: column;
      flex-shrink: 0;
    }

    .mix-mode-panel.active {
      display: flex;
    }

    .mix-mode-header {
      padding: 16px;
      border-bottom: 1px solid #333;
    }

    .mix-mode-title {
      font-size: 14px;
      font-weight: 600;
      color: #fff;
    }

    .mix-mode-subtitle {
      font-size: 10px;
      color: #666;
      margin-top: 4px;
    }

    .mix-mode-list {
      flex: 1;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      overflow-y: auto;
    }

    .mix-mode-item {
      padding: 14px;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .mix-mode-item:hover {
      background: #252525;
      border-color: #444;
    }

    .mix-mode-item.active {
      background: #0066ff15;
      border-color: #0066ff;
    }

    .mix-mode-item-title {
      font-size: 12px;
      font-weight: 600;
      color: #fff;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .mix-mode-item-title svg {
      width: 16px;
      height: 16px;
      color: #0066ff;
    }

    .mix-mode-item-desc {
      font-size: 10px;
      color: #888;
      line-height: 1.5;
    }

    .mix-mode-item-badge {
      font-size: 9px;
      padding: 2px 6px;
      background: #0066ff30;
      color: #0066ff;
      border-radius: 3px;
      margin-left: auto;
    }

    /* Mix 메인 영역 */
    .mix-main-area {
      display: none;
      flex: 1;
      flex-direction: column;
      background: #0a0a0a;
      min-width: 0;
    }

    .mix-main-area.active {
      display: flex;
    }

    .mix-toolbar {
      height: 48px;
      background: #141414;
      border-bottom: 1px solid #333;
      display: flex;
      align-items: center;
      padding: 0 16px;
      gap: 12px;
    }

    .mix-toolbar-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .mix-tool-btn {
      width: 32px;
      height: 32px;
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 6px;
      color: #ccc;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
    }

    .mix-tool-btn:hover {
      background: #444;
      color: #fff;
    }

    .mix-tool-btn.active {
      background: #0066ff;
      border-color: #0066ff;
      color: #fff;
    }

    .mix-tool-btn svg {
      width: 18px;
      height: 18px;
    }

    .mix-tool-divider {
      width: 1px;
      height: 24px;
      background: #333;
    }

    .mix-tool-label {
      font-size: 11px;
      color: #888;
    }

    .mix-canvas-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      background: #0d0d0d;
    }

    .mix-canvas-wrapper {
      position: relative;
      max-width: 100%;
      max-height: 100%;
    }

    .mix-canvas-wrapper canvas {
      display: block;
      max-width: 100%;
      max-height: 100%;
    }

    .mix-overlay-canvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }

    #mix-draw-canvas {
      pointer-events: auto;
      cursor: crosshair;
    }

    .mix-empty-state {
      color: #444;
      font-size: 14px;
      text-align: center;
    }

    .mix-empty-state svg {
      width: 64px;
      height: 64px;
      margin-bottom: 16px;
      color: #333;
    }

    .mix-empty-state p {
      margin-top: 8px;
      font-size: 11px;
      color: #666;
    }

    /* Mix 좌표 오버레이 */
    .mix-coord-overlay {
      position: absolute;
      bottom: 12px;
      left: 12px;
      background: rgba(0, 0, 0, 0.8);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 10px;
      font-family: 'Monaco', 'Consolas', monospace;
      color: #0f0;
      display: none;
    }

    .mix-coord-overlay.visible {
      display: block;
    }

    /* Mix 옵션 패널 */
    .mix-options-panel {
      display: none;
      width: 300px;
      background: #141414;
      border-left: 1px solid #333;
      flex-direction: column;
      flex-shrink: 0;
    }

    .mix-options-panel.active {
      display: flex;
    }

    .mix-options-header {
      padding: 16px;
      border-bottom: 1px solid #333;
    }

    .mix-options-title {
      font-size: 12px;
      font-weight: 600;
      color: #fff;
    }

    .mix-options-subtitle {
      font-size: 10px;
      color: #666;
      margin-top: 4px;
    }

    .mix-options-content {
      flex: 1;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      overflow-y: auto;
    }

    .mix-option-section {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .mix-option-label {
      font-size: 10px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .mix-option-label-badge {
      font-size: 8px;
      padding: 2px 4px;
      background: #ff3b3020;
      color: #ff3b30;
      border-radius: 2px;
    }

    .mix-option-input {
      width: 100%;
      height: 36px;
      padding: 0 12px;
      background: #0a0a0a;
      border: 1px solid #333;
      border-radius: 6px;
      color: #fff;
      font-size: 12px;
      outline: none;
    }

    .mix-option-input:focus {
      border-color: #0066ff;
    }

    .mix-option-textarea {
      width: 100%;
      min-height: 80px;
      padding: 10px 12px;
      background: #0a0a0a;
      border: 1px solid #333;
      border-radius: 6px;
      color: #fff;
      font-size: 12px;
      outline: none;
      resize: vertical;
      font-family: inherit;
      line-height: 1.5;
    }

    .mix-option-textarea:focus {
      border-color: #0066ff;
    }

    /* Mix 업로드 영역 */
    .mix-upload-area {
      border: 2px dashed #333;
      border-radius: 8px;
      padding: 24px;
      text-align: center;
      cursor: pointer;
      transition: all 0.15s;
    }

    .mix-upload-area:hover {
      border-color: #0066ff;
      background: #0066ff08;
    }

    .mix-upload-area.has-image {
      border-style: solid;
      border-color: #30d158;
      background: #30d15808;
    }

    .mix-upload-area svg {
      width: 32px;
      height: 32px;
      color: #555;
      margin-bottom: 8px;
    }

    .mix-upload-area p {
      font-size: 11px;
      color: #888;
    }

    .mix-upload-preview {
      max-width: 100%;
      max-height: 100px;
      border-radius: 4px;
      margin-top: 8px;
    }

    /* Mix 슬라이더 */
    .mix-slider-container {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .mix-slider {
      flex: 1;
      height: 4px;
      -webkit-appearance: none;
      background: #333;
      border-radius: 2px;
      outline: none;
    }

    .mix-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: #0066ff;
      border-radius: 50%;
      cursor: pointer;
    }

    .mix-slider-value {
      font-size: 11px;
      color: #fff;
      min-width: 50px;
      text-align: right;
      font-family: 'Monaco', 'Consolas', monospace;
    }

    /* Mix 핫스팟 마커 */
    .mix-hotspot-marker {
      position: absolute;
      width: 28px;
      height: 28px;
      background: #ff3b30;
      border: 2px solid #fff;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      cursor: move;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: 600;
      color: #fff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.5);
      z-index: 10;
      transition: transform 0.1s;
    }

    .mix-hotspot-marker:hover {
      background: #ff6b60;
      transform: translate(-50%, -50%) scale(1.1);
    }

    .mix-hotspot-marker.selected {
      background: #0066ff;
      box-shadow: 0 0 0 4px rgba(0,102,255,0.3);
    }

    /* Mix 핫스팟 목록 */
    .mix-hotspot-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 200px;
      overflow-y: auto;
    }

    .mix-hotspot-item {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 10px;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      cursor: pointer;
    }

    .mix-hotspot-item:hover {
      border-color: #444;
    }

    .mix-hotspot-item.selected {
      border-color: #0066ff;
      background: #0066ff10;
    }

    .mix-hotspot-item-header {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .mix-hotspot-item-num {
      width: 24px;
      height: 24px;
      background: #ff3b30;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: 600;
      color: #fff;
    }

    .mix-hotspot-item.selected .mix-hotspot-item-num {
      background: #0066ff;
    }

    .mix-hotspot-item-info {
      flex: 1;
      min-width: 0;
    }

    .mix-hotspot-item-name {
      font-size: 11px;
      color: #fff;
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .mix-hotspot-item-coords {
      font-size: 9px;
      color: #666;
      font-family: 'Monaco', 'Consolas', monospace;
      margin-top: 2px;
    }

    .mix-hotspot-item-delete {
      width: 24px;
      height: 24px;
      background: transparent;
      border: none;
      color: #666;
      cursor: pointer;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .mix-hotspot-item-delete:hover {
      background: #ff3b30;
      color: #fff;
    }

    /* Mix 액션 버튼 */
    .mix-options-actions {
      padding: 16px;
      border-top: 1px solid #333;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    /* Mix 상태바 */
    .mix-status-bar {
      height: 28px;
      background: #141414;
      border-top: 1px solid #333;
      padding: 0 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 10px;
      color: #666;
    }

    /* Mix 색상 버튼 */
    .mix-color-picker-row {
      display: flex;
      gap: 8px;
    }

    .mix-color-btn {
      width: 28px;
      height: 28px;
      border: 2px solid transparent;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .mix-color-btn:hover {
      transform: scale(1.1);
    }

    .mix-color-btn.active {
      border-color: #fff;
    }

    .mix-color-btn.red { background: rgba(255, 59, 48, 0.6); }
    .mix-color-btn.blue { background: rgba(0, 102, 255, 0.6); }
    .mix-color-btn.green { background: rgba(48, 209, 88, 0.6); }
    .mix-color-btn.yellow { background: rgba(255, 214, 10, 0.6); }

    /* Mix 파라미터 그리드 */
    .mix-param-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .mix-param-item {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .mix-param-item label {
      font-size: 10px;
      color: #666;
    }

    .mix-param-item input {
      height: 32px;
      padding: 0 10px;
      background: #0a0a0a;
      border: 1px solid #333;
      border-radius: 4px;
      color: #fff;
      font-size: 11px;
    }

    .mix-param-item input:focus {
      border-color: #0066ff;
      outline: none;
    }

    /* Mix 로딩 오버레이 */
    .mix-loading-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    .mix-loading-overlay.hidden {
      display: none;
    }

    /* Render 모드 비활성화 시 숨김 */
    .render-mode-content {
      display: flex;
      flex: 1;
      min-width: 0;
    }

    .render-mode-content.hidden {
      display: none;
    }

    /* Mix 모드 전체 컨테이너 */
    .mix-mode-container {
      display: none;
      flex: 1;
      min-width: 0;
    }

    .mix-mode-container.active {
      display: flex;
    }

    /* Scene Tabs */
    .scene-tabs {
      display: flex;
      background: #141414;
      border-bottom: 1px solid #333;
      padding: 0 8px;
      overflow-x: auto;
      flex-shrink: 0;
      height: 32px;
      align-items: flex-end;
      gap: 2px;
    }

    .scene-tabs::-webkit-scrollbar {
      height: 4px;
    }

    .scene-tabs::-webkit-scrollbar-thumb {
      background: #444;
      border-radius: 2px;
    }

    .scene-tab {
      padding: 6px 14px;
      background: #1a1a1a;
      border: 1px solid #333;
      border-bottom: none;
      border-radius: 6px 6px 0 0;
      color: #888;
      font-size: 11px;
      cursor: pointer;
      white-space: nowrap;
      transition: all 0.15s;
      position: relative;
      top: 1px;
    }

    .scene-tab:hover {
      background: #252525;
      color: #ccc;
    }

    .scene-tab.active {
      background: #0a0a0a;
      color: #fff;
      border-color: #333;
    }

    .scene-add-btn {
      width: 28px;
      height: 24px;
      background: #2a2a2a;
      border: 1px solid #444;
      border-bottom: none;
      border-radius: 6px 6px 0 0;
      color: #888;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      margin-left: 4px;
      transition: all 0.15s;
      position: relative;
      top: 1px;
    }

    .scene-add-btn:hover {
      background: #0066ff;
      border-color: #0066ff;
      color: #fff;
    }

    /* 씬 탭 렌더링 로딩 아이콘 */
    .scene-tab-content {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .scene-tab-spinner {
      width: 12px;
      height: 12px;
      border: 2px solid #555;
      border-top-color: #0066ff;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    .scene-tab.rendering {
      background: #1a2a3a;
      border-color: #0066ff;
      color: #0066ff;
    }

    .scene-tab.render-complete {
      background: #1a3a2a;
      border-color: #30d158;
      color: #30d158;
    }

    .scene-tab.render-error {
      background: #3a1a1a;
      border-color: #ff3b30;
      color: #ff3b30;
    }

    /* ========================================
       Node Editor Mode - VizMaker Style
       ======================================== */
    .node-editor-container {
      display: none;
      flex: 1;
      min-width: 0;
      flex-direction: column;
    }

    .node-editor-container.active {
      display: flex;
    }

    /* 노드 캔버스 영역 */
    .node-canvas-wrapper {
      flex: 1;
      display: flex;
      position: relative;
    }

    .node-canvas-area {
      flex: 1;
      background: #0d1117;
      position: relative;
      overflow: hidden;
    }

    .node-canvas {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }

    /* 그리드 배경 - 더 미세하게 */
    .node-canvas-grid {
      width: 100%;
      height: 100%;
      background-image:
        radial-gradient(circle, rgba(255,255,255,0.08) 1px, transparent 1px);
      background-size: 24px 24px;
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }

    /* 노드 공통 스타일 - VizMaker */
    .node {
      position: absolute;
      left: 0;
      top: 0;
      background: #1c2128;
      border: 2px solid #30363d;
      border-radius: 8px;
      width: 320px;
      cursor: move;
      user-select: none;
      will-change: transform;
      transition: box-shadow 0.15s, border-color 0.15s;
      z-index: 10;
      overflow: visible;
    }

    .node:hover {
      border-color: #484f58;
    }

    .node.selected {
      border-color: #00d4aa;
      box-shadow: 0 0 0 1px #00d4aa, 0 8px 24px rgba(0, 212, 170, 0.15);
      z-index: 20;
    }

    .node.dirty::before {
      content: '';
      position: absolute;
      top: -3px;
      right: -3px;
      width: 8px;
      height: 8px;
      background: #f0883e;
      border-radius: 50%;
      z-index: 20;
    }

    /* 노드 썸네일 */
    .node-thumbnail {
      width: 100%;
      aspect-ratio: 16/9;
      background: #0d1117;
      border-radius: 6px 6px 0 0;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .node-thumbnail img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .node-thumbnail-empty {
      color: #484f58;
      font-size: 11px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
    }

    .node-thumbnail-empty svg {
      width: 32px;
      height: 32px;
      opacity: 0.5;
    }

    /* 노드 헤더 (이미지 없을 때) */
    .node-header {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px;
    }

    .node-header-icon {
      width: 48px;
      height: 48px;
      opacity: 0.4;
    }

    .node-header-icon svg {
      width: 48px;
      height: 48px;
    }

    /* 노드 라벨 - 카드 바깥 아래 */
    .node-label-outside {
      text-align: center;
      padding: 8px 0 0;
    }

    /* 미니툴바 - 카드 선택 시 카드 위에 표시 */
    .node-mini-toolbar {
      position: absolute;
      top: -48px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      align-items: center;
      gap: 4px;
      background: rgba(72, 79, 88, 0.85);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border-radius: 24px;
      padding: 6px 14px;
      z-index: 200;
      pointer-events: auto;
    }
    .node.selected .node-mini-toolbar {
      display: flex;
    }
    .node-mini-toolbar-btn {
      width: 32px;
      height: 32px;
      border: none;
      background: none;
      color: #c9d1d9;
      cursor: pointer;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      transition: background 0.12s;
    }
    .node-mini-toolbar-btn:hover {
      background: rgba(255,255,255,0.15);
      color: #fff;
    }
    .node-mini-toolbar-btn svg {
      width: 22px;
      height: 22px;
    }

    /* 노드 푸터 (라벨) - 카드 안 */
    .node-footer {
      padding: 8px 12px;
    }

    .node-title {
      font-size: 12px;
      font-weight: 600;
      color: #e6edf3;
      margin-bottom: 2px;
    }

    .node-subtitle {
      font-size: 10px;
      color: #7d8590;
    }

    /* Source 노드 - 회색 톤 */
    .node-source {
      background: #2d333b;
      border-color: #444c56;
    }

    .node-source.selected {
      border-color: #00d4aa;
    }

    .node-source .node-thumbnail {
      background: #22272e;
    }

    /* Renderer 노드 */
    .node-renderer {
      background: #1c2128;
    }

    /* Animation 노드 */
    .node-animation {
      background: #1c2128;
    }
    .node-animation.selected {
      border-color: #da70d6;
      box-shadow: 0 0 12px rgba(218, 112, 214, 0.3);
    }

    .node-renderer.selected {
      border-color: #00d4aa;
    }

    /* 노드 포트 (연결점) */
    .node-port {
      position: absolute;
      width: 14px;
      height: 14px;
      background: #30363d;
      border: 2px solid #484f58;
      border-radius: 50%;
      cursor: crosshair;
      transition: all 0.15s;
      z-index: 15;
    }

    .node-port:hover {
      background: #00d4aa;
      border-color: #00d4aa;
      transform: scale(1.2);
    }

    .node-port.connected {
      background: #00d4aa;
      border-color: #00d4aa;
    }

    .node-port-input {
      left: -8px;
      top: 50%;
      transform: translateY(-50%);
    }

    .node-port-output {
      right: -8px;
      top: 50%;
      transform: translateY(-50%);
    }

    /* 연결선 SVG */
    .node-connections {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
    }

    .node-connection {
      fill: none;
      stroke: #00d4aa;
      stroke-width: 2;
    }

    .node-connection-preview {
      stroke: #00d4aa;
      stroke-dasharray: 5, 5;
      opacity: 0.5;
    }

    /* 우측 Inspector 패널 - VizMaker */
    .node-inspector {
      width: 300px;
      background: #161b22;
      border-left: 1px solid #30363d;
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
    }

    /* 상단 Preview + 탭 */
    .node-inspector-preview {
      border-bottom: 1px solid #30363d;
    }

    .node-inspector-tabs {
      display: flex;
      padding: 0 16px;
      border-bottom: 1px solid #30363d;
      gap: 4px;
    }

    .node-inspector-tab {
      padding: 10px 16px;
      font-size: 12px;
      color: #7d8590;
      background: transparent;
      border: none;
      cursor: pointer;
      position: relative;
    }

    .node-inspector-tab.active {
      color: #e6edf3;
    }

    .node-inspector-tab.active::after {
      content: '';
      position: absolute;
      bottom: -1px;
      left: 0;
      right: 0;
      height: 2px;
      background: #00d4aa;
    }

    .node-inspector-preview-image {
      aspect-ratio: 16/9;
      background: #0d1117;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .node-inspector-preview-image img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .node-inspector-preview-empty {
      color: #484f58;
      font-size: 12px;
    }

    .node-inspector-preview-progress {
      height: 4px;
      background: #30363d;
    }

    .node-inspector-preview-progress-bar {
      height: 100%;
      background: #00d4aa;
      width: 0%;
      transition: width 0.3s;
    }

    /* Inspector 컨텐츠 */
    .node-inspector-content {
      flex: 1;
      overflow-y: auto;
      padding: 0;
    }

    /* 아코디언 섹션 */
    .node-inspector-accordion {
      border-bottom: 1px solid #30363d;
    }

    .node-inspector-accordion-header {
      display: flex;
      align-items: center;
      padding: 12px 16px;
      cursor: pointer;
      gap: 8px;
    }

    .node-inspector-accordion-header:hover {
      background: #1c2128;
    }

    .node-inspector-accordion-icon {
      width: 20px;
      height: 20px;
      color: #7d8590;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .node-inspector-accordion-icon svg {
      width: 16px;
      height: 16px;
    }

    .node-inspector-accordion-title {
      flex: 1;
      font-size: 13px;
      font-weight: 500;
      color: #e6edf3;
    }

    .node-inspector-accordion-toggle {
      color: #7d8590;
      transition: transform 0.2s;
    }

    .node-inspector-accordion-toggle svg {
      width: 16px;
      height: 16px;
    }

    .node-inspector-accordion.open .node-inspector-accordion-toggle {
      transform: rotate(180deg);
    }

    .node-inspector-accordion-body {
      padding: 0 16px 16px;
      display: none;
    }

    .node-inspector-accordion.open .node-inspector-accordion-body {
      display: block;
    }

    /* 설정 항목 */
    .node-setting-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .node-setting-label {
      font-size: 12px;
      color: #7d8590;
    }

    .node-setting-value {
      background: #0d1117;
      border: 1px solid #30363d;
      border-radius: 6px;
      padding: 6px 12px;
      font-size: 12px;
      color: #e6edf3;
      min-width: 120px;
      text-align: left;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .node-setting-value svg {
      width: 12px;
      height: 12px;
      color: #7d8590;
    }

    /* Prompt Presets 그리드 - VizMaker */
    .prompt-presets-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
    }

    .prompt-preset-btn {
      aspect-ratio: 1;
      background: #0d1117;
      border: 1px solid #30363d;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 10px 4px;
      transition: all 0.15s;
    }

    .prompt-preset-btn:hover {
      background: #1c2128;
      border-color: #484f58;
    }

    .prompt-preset-btn.active {
      background: rgba(0, 212, 170, 0.1);
      border-color: #00d4aa;
    }

    .prompt-preset-btn svg {
      width: 24px;
      height: 24px;
      color: #7d8590;
    }

    .prompt-preset-btn.active svg {
      color: #00d4aa;
    }

    .prompt-preset-btn span {
      font-size: 9px;
      color: #7d8590;
      text-align: center;
      line-height: 1.2;
    }

    .prompt-preset-btn.active span {
      color: #00d4aa;
    }

    /* 하단 프롬프트 바 */
    .node-bottom-bar {
      display: flex;
      align-items: center;
      padding: 12px 16px;
      background: #161b22;
      border-top: 1px solid #30363d;
      gap: 12px;
    }

    .node-bottom-prompt {
      flex: 1;
    }

    .node-prompt-input {
      width: 100%;
      background: #0d1117;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 10px 14px;
      font-size: 13px;
      color: #e6edf3;
      outline: none;
    }

    .node-prompt-input::placeholder {
      color: #484f58;
    }

    .node-prompt-input:focus {
      border-color: #00d4aa;
    }

    .node-make-btn {
      padding: 10px 24px;
      background: #00d4aa;
      border: none;
      border-radius: 8px;
      color: #0d1117;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.15s;
      white-space: nowrap;
    }

    .node-make-btn:hover {
      background: #00e6b8;
    }

    .node-make-btn:disabled {
      background: #30363d;
      color: #484f58;
      cursor: not-allowed;
    }

    .node-make-btn svg {
      width: 16px;
      height: 16px;
    }

    .node-credits {
      font-size: 11px;
      color: #484f58;
    }

    /* 노드 에디터 빈 상태 */
    .node-inspector-empty {
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      flex: 1;
      color: #484f58;
      text-align: center;
      padding: 40px;
    }

    .node-inspector-empty:not(.hidden) {
      display: flex;
    }

    .node-inspector-empty svg {
      width: 40px;
      height: 40px;
      margin-bottom: 12px;
      opacity: 0.4;
    }

    /* 노드 Progress */
    .node-progress {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: transparent;
      border-radius: 6px 6px 0 0;
      overflow: hidden;
    }

    .node-progress-bar {
      height: 100%;
      background: #00d4aa;
      width: 0%;
      transition: width 0.3s;
    }

    .node.processing .node-progress-bar {
      animation: node-progress-pulse 1.5s ease-in-out infinite;
    }

    @keyframes node-progress-pulse {
      0%, 100% { width: 20%; margin-left: 0; }
      50% { width: 60%; margin-left: 40%; }
    }

    /* 노드 캔버스 상단 Enlarge 버튼 */
    .node-canvas-topbar {
      position: absolute;
      top: 12px;
      right: 12px;
      z-index: 100;
      display: flex;
      gap: 8px;
    }

    .node-canvas-btn {
      padding: 6px 12px;
      background: #1c2128;
      border: 1px solid #30363d;
      border-radius: 6px;
      color: #7d8590;
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .node-canvas-btn:hover {
      background: #2d333b;
      color: #e6edf3;
    }

    .node-canvas-btn svg {
      width: 14px;
      height: 14px;
    }
  </style>
</head>
<body>
  <!-- 초기 로딩 화면 -->
  <div class="app-loader" id="app-loader">
    <div class="app-loader-logo">Nano<span>Banana</span></div>
    <div class="app-loader-spinner"></div>
    <div class="app-loader-text">Loading renderer...</div>
  </div>

  <!-- 좌측 아이콘 메뉴바 -->
  <nav class="icon-menu">
    <button class="icon-menu-item active" id="menu-render" title="Render">
      <svg viewBox="0 0 24 24" fill="currentColor">
        <path d="M.968 9.027l7.717 4.428-.006 1.32-4.39-2.518-2.763 1.57 7.148 4.12.005 1.27-7.658-4.405c.02.516.488 2.106 1.383 3.337.91 1.247 1.946 1.776 1.946 1.776L11.428 24V11.849L.975 5.846zm22.064-3.8L15.22.723S13.982 0 12.008 0C9.952 0 8.76.746 8.76.746l-7.236 4.14 11.009 6.328V24l7.245-4.136s1.295-.715 2.279-2.414c.867-1.496.975-2.943.975-2.943zM11.251 7.308s1.615-.298 2.98.49l2.171 1.25s.003 1.097.003 2.736c0 1.313-1.112 2.674-1.112 2.674l.002-4.816zm6.402 10.562l-2.358 1.353v-1.269l1.835-1.05c1.748-1.26 2.037-3.117 2.037-3.761l-.007-5.705-5.006-2.881s-.76-.499-2.129-.499c-1.367 0-2.113.461-2.113.461L8.154 5.53l-1.11-.641L9.473 3.5s.95-.527 2.544-.527c1.462 0 2.6.571 2.6.571L20.27 6.81l-.007 6.226c.04.957-.406 3.296-2.61 4.835z"/>
      </svg>
    </button>
    <button class="icon-menu-item" id="menu-camera" title="Camera">
      <svg viewBox="0 0 24 24" fill="currentColor">
        <path d="M18 3C19.6569 3 21 4.34315 21 6C21 7.65685 19.6569 9 18 9H15C13.6941 9 12.5831 8.16562 12.171 7.0009L11 7C9.9 7 9 7.9 9 9L9.0009 9.17102C10.1656 9.58312 11 10.6941 11 12C11 13.3059 10.1656 14.4169 9.0009 14.829L9 15C9 16.1 9.9 17 11 17L12.1707 17.0001C12.5825 15.8349 13.6937 15 15 15H18C19.6569 15 21 16.3431 21 18C21 19.6569 19.6569 21 18 21H15C13.6941 21 12.5831 20.1656 12.171 19.0009L11 19C8.79 19 7 17.21 7 15H5C3.34315 15 2 13.6569 2 12C2 10.3431 3.34315 9 5 9H7C7 6.79086 8.79086 5 11 5L12.1707 5.00009C12.5825 3.83485 13.6937 3 15 3H18ZM18 17H15C14.4477 17 14 17.4477 14 18C14 18.5523 14.4477 19 15 19H18C18.5523 19 19 18.5523 19 18C19 17.4477 18.5523 17 18 17ZM8 11H5C4.44772 11 4 11.4477 4 12C4 12.5523 4.44772 13 5 13H8C8.55228 13 9 12.5523 9 12C9 11.4477 8.55228 11 8 11ZM18 5H15C14.4477 5 14 5.44772 14 6C14 6.55228 14.4477 7 15 7H18C18.5523 7 19 6.55228 19 6C19 5.44772 18.5523 5 18 5Z"/>
      </svg>
    </button>
    <button class="icon-menu-item" id="menu-mix" title="Mix">
      <svg viewBox="0 0 15 15" fill="currentColor">
        <path d="M1.59979 8.82434C1.59991 8.32473 2.10284 7.99678 2.54999 8.17004L2.63885 8.21204L6.57245 10.3878L6.65741 10.4425C7.02571 10.7193 7.02591 11.282 6.65741 11.5587L6.57245 11.6134L2.63885 13.7892C2.17257 14.0469 1.60035 13.7095 1.59979 13.1769V8.82434ZM13.0002 8.29993C13.3867 8.30002 13.7004 8.61358 13.7004 9.00012V13.0001C13.7003 13.3866 13.3867 13.7002 13.0002 13.7003H9.00018C8.61362 13.7003 8.30004 13.3867 8.29999 13.0001V9.00012C8.29999 8.61352 8.61358 8.29993 9.00018 8.29993H13.0002ZM2.50018 12.8361L5.81952 11.0001L2.50018 9.16321V12.8361ZM9.20038 12.7999H12.8V9.20032H9.20038V12.7999ZM4.00018 1.24915C5.51931 1.24925 6.75114 2.48097 6.75116 4.00012C6.75105 5.5192 5.51926 6.75099 4.00018 6.7511C2.48103 6.75108 1.24931 5.51925 1.24921 4.00012C1.24922 2.48091 2.48098 1.24916 4.00018 1.24915ZM12.8068 1.55676C12.9826 1.38103 13.2678 1.38103 13.4435 1.55676C13.6191 1.73251 13.6192 2.01781 13.4435 2.19348L11.6369 4.00012L13.4435 5.80676L13.5012 5.87708C13.6165 6.05174 13.5973 6.2897 13.4435 6.44348C13.2898 6.59725 13.0518 6.61646 12.8771 6.5011L12.8068 6.44348L11.0002 4.63684L9.19354 6.44348C9.01787 6.61913 8.73257 6.61902 8.55682 6.44348C8.38109 6.26775 8.38111 5.9825 8.55682 5.80676L10.3635 4.00012L8.55682 2.19348L8.49921 2.12317C8.38371 1.94849 8.403 1.7106 8.55682 1.55676C8.71066 1.40293 8.94854 1.38364 9.12323 1.49915L9.19354 1.55676L11.0002 3.3634L12.8068 1.55676ZM4.00018 2.14954C2.97803 2.14955 2.14961 2.97797 2.1496 4.00012C2.1497 5.0222 2.97809 5.85069 4.00018 5.85071C5.0222 5.8506 5.85066 5.02214 5.85077 4.00012C5.85075 2.97803 5.02226 2.14964 4.00018 2.14954Z"/>
      </svg>
    </button>
    <button class="icon-menu-item" id="menu-history" title="History">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="10"></circle>
        <polyline points="12 6 12 12 16 14"></polyline>
      </svg>
    </button>
    <div class="icon-menu-divider"></div>
    <div class="icon-menu-spacer"></div>
    <button class="icon-menu-item" id="menu-help" title="Help">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="10"></circle>
        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
        <line x1="12" y1="17" x2="12.01" y2="17"></line>
      </svg>
    </button>
    <button class="icon-menu-item" id="menu-settings" title="Settings">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="3"></circle>
        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
      </svg>
    </button>
  </nav>

  <!-- Mix 모드 좌측 패널 -->
  <aside class="mix-mode-panel" id="mix-mode-panel">
    <div class="mix-mode-header">
      <div class="mix-mode-title">Mix Mode</div>
      <div class="mix-mode-subtitle">AI Scene Mixing System</div>
    </div>
    <div class="mix-mode-list">
      <div class="mix-mode-item active" data-mixmode="add-remove">
        <div class="mix-mode-item-title">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"></circle>
            <line x1="12" y1="8" x2="12" y2="16"></line>
            <line x1="8" y1="12" x2="16" y2="12"></line>
          </svg>
          Object Insert & Remove
          <span class="mix-mode-item-badge">3D</span>
        </div>
        <div class="mix-mode-item-desc">3D 월드 좌표 기반으로 가구/소품을 정확한 위치에 배치하거나 제거합니다.</div>
      </div>
      <div class="mix-mode-item" data-mixmode="inpaint">
        <div class="mix-mode-item-title">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 19l7-7 3 3-7 7-3-3z"></path>
            <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path>
          </svg>
          Inpainting
        </div>
        <div class="mix-mode-item-desc">마스킹 영역만 수정하고 나머지 씬은 픽셀 단위까지 그대로 유지합니다.</div>
      </div>
      <div class="mix-mode-item" data-mixmode="material">
        <div class="mix-mode-item-title">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
            <line x1="3" y1="9" x2="21" y2="9"></line>
            <line x1="9" y1="21" x2="9" y2="9"></line>
          </svg>
          Material Replace
        </div>
        <div class="mix-mode-item-desc">벽/바닥/천장에 새로운 재질을 실제 공간에 맞게 투영합니다.</div>
      </div>
      <div class="mix-mode-item" data-mixmode="floorplan">
        <div class="mix-mode-item-title">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"></polygon>
            <line x1="8" y1="2" x2="8" y2="18"></line>
            <line x1="16" y1="6" x2="16" y2="22"></line>
          </svg>
          Floorplan to Isometric
        </div>
        <div class="mix-mode-item-desc">2D 평면도를 분석하여 3D 아이소메트릭 뷰로 자동 변환합니다.</div>
      </div>
    </div>
  </aside>

  <!-- 좌측 사이드바 -->
  <aside class="sidebar" id="render-sidebar">
    <div class="sidebar-header">
      <div class="logo">NanoBanana</div>
    </div>

    <div class="sidebar-content">
      <div class="control-section">
        <span class="section-label">Time</span>
        <div class="segmented" id="time-group">
          <button class="seg-btn active" data-time="day">Day</button>
          <button class="seg-btn" data-time="evening">Eve</button>
          <button class="seg-btn" data-time="night">Night</button>
        </div>
      </div>

      <div class="control-section">
        <span class="section-label">Lights</span>
        <div class="segmented" id="light-group">
          <button class="seg-btn active" data-light="on">On</button>
          <button class="seg-btn" data-light="off">Off</button>
        </div>
      </div>

      <div class="control-section">
        <span class="section-label">Engine</span>
        <div class="segmented" id="engine-group">
          <button class="seg-btn active" data-engine="gemini">Gemini</button>
          <button class="seg-btn" data-engine="replicate">Replicate</button>
        </div>
      </div>

      <div class="control-section">
        <span class="section-label">Model</span>
        <div class="custom-dropdown" id="model-dropdown">
          <div class="dropdown-selected" id="model-dropdown-selected">
            <span id="model-selected-text">Flash 2.0 (추천)</span>
            <span class="dropdown-arrow"></span>
          </div>
          <div class="dropdown-menu" id="model-dropdown-menu">
            <div class="dropdown-group-label">Gemini</div>
            <div class="dropdown-item selected" data-value="gemini-2.0-flash-exp" data-engine="gemini">
              Flash 2.0 (추천)
              <div class="dropdown-item-desc">20~40초, 고속</div>
            </div>
            <div class="dropdown-item" data-value="gemini-2.5-flash-image" data-engine="gemini">
              Flash 2.5
              <div class="dropdown-item-desc">30~60초</div>
            </div>
            <div class="dropdown-item" data-value="gemini-3-pro-image" data-engine="gemini">
              Gemini 3 Pro
              <div class="dropdown-item-desc">1~2분, 최고품질</div>
            </div>
            <div class="dropdown-group-label">Imagen</div>
            <div class="dropdown-item" data-value="imagen-4.0-fast-generate-001" data-engine="gemini">
              Imagen 4 Fast
              <div class="dropdown-item-desc">20~40초, 고속</div>
            </div>
            <div class="dropdown-item" data-value="imagen-4.0-generate-001" data-engine="gemini">
              Imagen 4
              <div class="dropdown-item-desc">1~2분, 고품질</div>
            </div>
            <div class="dropdown-group-label">Replicate (ControlNet)</div>
            <div class="dropdown-item" data-value="photorealistic-fx" data-engine="replicate">
              PhotoFX
              <div class="dropdown-item-desc">10초, 구도 유지</div>
            </div>
            <div class="dropdown-item" data-value="sdxl-controlnet" data-engine="replicate">
              SDXL ControlNet
              <div class="dropdown-item-desc">20초, 고품질</div>
            </div>
            <div class="dropdown-item" data-value="flux-canny" data-engine="replicate">
              Flux Canny
              <div class="dropdown-item-desc">15초, 윤곽선 기반</div>
            </div>
          </div>
        </div>
      </div>

      <div class="control-section">
        <span class="section-label">Size</span>
        <div class="segmented" id="size-group">
          <button class="seg-btn active" data-size="1024">속도</button>
          <button class="seg-btn" data-size="1536">밸런스</button>
          <button class="seg-btn" data-size="1920">고품질</button>
        </div>
      </div>

      <div class="control-section">
        <span class="section-label">Camera</span>
        <div class="camera-btns-row">
          <button class="btn btn-mirror" id="btn-mirror">Mirror</button>
          <button class="btn btn-2point" id="btn-2point" title="2점 투시 자동 보정">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="3" y="3" width="18" height="18" rx="2"/>
              <line x1="12" y1="3" x2="12" y2="21"/>
              <line x1="3" y1="12" x2="21" y2="12"/>
            </svg>
          </button>
        </div>
        <div class="camera-controls">
          <div class="camera-move">
            <div class="move-row">
              <button class="cam-btn wasd" id="cam-forward" title="Forward (W)">W</button>
            </div>
            <div class="move-row">
              <button class="cam-btn wasd" id="cam-left" title="Left (A)">A</button>
              <button class="cam-btn wasd" id="cam-back" title="Back (S)">S</button>
              <button class="cam-btn wasd" id="cam-right" title="Right (D)">D</button>
            </div>
          </div>
          <div class="camera-height">
            <button class="cam-btn small" id="cam-up" title="Up (Q)">Q</button>
            <button class="cam-btn small" id="cam-down" title="Down (E)">E</button>
          </div>
          <div class="camera-rotate">
            <button class="cam-btn small" id="cam-rot-left" title="Rotate Left (Z)">Z</button>
            <button class="cam-btn small" id="cam-rot-right" title="Rotate Right (X)">X</button>
          </div>
        </div>
        <div class="keyboard-hint">WASD 이동 | QE 높이 | ZX 회전</div>
      </div>

      <div class="control-section">
        <span class="section-label">Height</span>
        <div class="segmented" id="height-group">
          <button class="seg-btn" data-height="standing">서기</button>
          <button class="seg-btn active" data-height="seated">앉기</button>
          <button class="seg-btn" data-height="low_angle">낮음</button>
        </div>
      </div>

      <div class="control-section">
        <span class="section-label">FOV</span>
        <div class="segmented" id="fov-group">
          <button class="seg-btn" data-fov="wide">광각</button>
          <button class="seg-btn active" data-fov="standard">표준</button>
          <button class="seg-btn" data-fov="telephoto">망원</button>
        </div>
      </div>
    </div>

    <div class="sidebar-actions">
      <button class="btn btn-secondary" id="btn-capture">Convert</button>
      <button class="btn btn-secondary" id="btn-edit" disabled>Edit</button>
      <button class="btn btn-secondary" id="btn-save" disabled>Export</button>
    </div>

    <div class="sidebar-footer">
      <div class="status-indicator">
        <span class="status-dot" id="status-dot"></span>
        <span id="api-status">Checking...</span>
      </div>
      <button class="icon-btn" id="btn-settings" title="Settings">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="12" r="3"></circle>
          <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
        </svg>
      </button>
    </div>
  </aside>

  <!-- Mix 옵션 패널 (우측) -->
  <aside class="mix-options-panel" id="mix-options-panel">
    <div class="mix-options-header">
      <div class="mix-options-title" id="mix-options-title">Object Insert & Remove</div>
      <div class="mix-options-subtitle" id="mix-options-subtitle">3D 좌표 기반 오브젝트 배치</div>
    </div>

    <div class="mix-options-content">
      <!-- Add/Remove 옵션 -->
      <div class="mix-options-mode" id="mix-options-add-remove">
        <div class="mix-option-section">
          <span class="mix-option-label">
            Reference Image
            <span class="mix-option-label-badge">Required</span>
          </span>
          <div class="mix-upload-area" id="mix-upload-object">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
              <polyline points="17 8 12 3 7 8"></polyline>
              <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
            <p>Click to upload furniture/object image</p>
            <img class="mix-upload-preview hidden" id="mix-object-preview">
          </div>
          <input type="file" id="mix-object-file" accept="image/*" style="display:none">
        </div>

        <div class="mix-option-section">
          <span class="mix-option-label">Object Name</span>
          <input type="text" class="mix-option-input" id="mix-object-name" placeholder="e.g., Modern Dining Chair">
        </div>

        <div class="mix-option-section">
          <span class="mix-option-label">Estimated Size (mm)</span>
          <div class="mix-param-grid">
            <div class="mix-param-item">
              <label>Width</label>
              <input type="number" id="mix-object-width" value="500" min="100" max="5000">
            </div>
            <div class="mix-param-item">
              <label>Height</label>
              <input type="number" id="mix-object-height" value="800" min="100" max="5000">
            </div>
            <div class="mix-param-item">
              <label>Depth</label>
              <input type="number" id="mix-object-depth" value="500" min="100" max="5000">
            </div>
          </div>
        </div>

        <div class="mix-option-section">
          <span class="mix-option-label">Placement Instructions</span>
          <textarea class="mix-option-textarea" id="mix-object-instruction" placeholder="e.g., Place naturally on the floor, facing the window."></textarea>
        </div>

        <div class="mix-option-section">
          <span class="mix-option-label">Hotspots (3D Positions)</span>
          <div class="mix-hotspot-list" id="mix-hotspot-list">
            <div class="mix-empty-state" style="font-size:11px;padding:16px;color:#555;">
              스케치업 뷰포트에서 클릭하여 핫스팟을 추가하세요
            </div>
          </div>
        </div>
      </div>

      <!-- Inpaint 옵션 -->
      <div class="mix-options-mode hidden" id="mix-options-inpaint">
        <div class="mix-option-section">
          <span class="mix-option-label">Brush Size</span>
          <div class="mix-slider-container">
            <input type="range" class="mix-slider" id="mix-brush-size" min="5" max="100" value="30">
            <span class="mix-slider-value" id="mix-brush-size-value">30px</span>
          </div>
        </div>

        <div class="mix-option-section">
          <span class="mix-option-label">Mask Color</span>
          <div class="mix-color-picker-row">
            <button class="mix-color-btn red active" data-color="rgba(255, 59, 48, 0.5)"></button>
            <button class="mix-color-btn blue" data-color="rgba(0, 102, 255, 0.5)"></button>
            <button class="mix-color-btn green" data-color="rgba(48, 209, 88, 0.5)"></button>
            <button class="mix-color-btn yellow" data-color="rgba(255, 214, 10, 0.5)"></button>
          </div>
        </div>

        <div class="mix-option-section">
          <span class="mix-option-label">
            Edit Instruction
            <span class="mix-option-label-badge">Required</span>
          </span>
          <textarea class="mix-option-textarea" id="mix-inpaint-instruction" placeholder="e.g., Change the sofa to a vintage brown leather chesterfield sofa"></textarea>
        </div>

        <div class="mix-option-section">
          <span class="mix-option-label">Preserve Settings</span>
          <label style="display:flex;align-items:center;gap:8px;font-size:11px;color:#ccc;margin-top:4px;">
            <input type="checkbox" id="mix-preserve-lighting" checked> Lighting & Shadows
          </label>
          <label style="display:flex;align-items:center;gap:8px;font-size:11px;color:#ccc;margin-top:4px;">
            <input type="checkbox" id="mix-preserve-style" checked> Material Style & Tone
          </label>
        </div>
      </div>

      <!-- Material 옵션 -->
      <div class="mix-options-mode hidden" id="mix-options-material">
        <div class="mix-option-section">
          <span class="mix-option-label">Brush Size</span>
          <div class="mix-slider-container">
            <input type="range" class="mix-slider" id="mix-material-brush-size" min="5" max="100" value="40">
            <span class="mix-slider-value" id="mix-material-brush-size-value">40px</span>
          </div>
        </div>

        <div class="mix-option-section">
          <span class="mix-option-label">
            Material Texture Image
            <span class="mix-option-label-badge">Required</span>
          </span>
          <div class="mix-upload-area" id="mix-upload-material">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
              <polyline points="17 8 12 3 7 8"></polyline>
              <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
            <p>Click to upload material texture</p>
            <img class="mix-upload-preview hidden" id="mix-material-preview">
          </div>
          <input type="file" id="mix-material-file" accept="image/*" style="display:none">
        </div>

        <div class="mix-option-section">
          <span class="mix-option-label">Material Description</span>
          <textarea class="mix-option-textarea" id="mix-material-description" placeholder="e.g., Herringbone oak wood flooring, natural matte finish"></textarea>
        </div>
      </div>

      <!-- Floorplan 옵션 -->
      <div class="mix-options-mode hidden" id="mix-options-floorplan">
        <div class="mix-option-section">
          <span class="mix-option-label">
            2D Floorplan Image
            <span class="mix-option-label-badge">Required</span>
          </span>
          <div class="mix-upload-area" id="mix-upload-floorplan">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
              <polyline points="17 8 12 3 7 8"></polyline>
              <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
            <p>Click to upload 2D floorplan (PNG/PDF)</p>
            <img class="mix-upload-preview hidden" id="mix-floorplan-preview">
          </div>
          <input type="file" id="mix-floorplan-file" accept="image/*,.pdf" style="display:none">
        </div>

        <div class="mix-option-section">
          <span class="mix-option-label">Space Parameters</span>
          <div class="mix-param-grid">
            <div class="mix-param-item">
              <label>Wall Height (mm)</label>
              <input type="number" id="mix-wall-height" value="2400" min="2000" max="5000">
            </div>
            <div class="mix-param-item">
              <label>Wall Thickness (mm)</label>
              <input type="number" id="mix-wall-thickness" value="100" min="50" max="500">
            </div>
          </div>
        </div>

        <div class="mix-option-section">
          <span class="mix-option-label">Interior Style</span>
          <select class="mix-option-input" id="mix-floorplan-style">
            <option value="modern">Modern Minimalist</option>
            <option value="scandinavian">Scandinavian</option>
            <option value="industrial">Industrial</option>
            <option value="classic">Classic Traditional</option>
            <option value="luxury">Luxury High-End</option>
            <option value="japandi">Japandi</option>
          </select>
        </div>

        <div class="mix-option-section">
          <span class="mix-option-label">Additional Instructions</span>
          <textarea class="mix-option-textarea" id="mix-floorplan-instruction" placeholder="e.g., Add appropriate furniture for each room, warm artificial lighting"></textarea>
        </div>
      </div>
    </div>

    <div class="mix-options-actions">
      <button class="btn btn-primary" id="mix-btn-apply" disabled>
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="20 6 9 17 4 12"></polyline>
        </svg>
        Apply Mix
      </button>
      <button class="btn btn-secondary" id="mix-btn-back">Back to Render</button>
    </div>
  </aside>

  <!-- Mix 메인 작업 영역 -->
  <main class="mix-main-area" id="mix-main-area">
    <div class="mix-toolbar">
      <!-- Add/Remove 모드 툴바 -->
      <div class="mix-toolbar-group" id="mix-toolbar-add-remove">
        <button class="mix-tool-btn active" id="mix-tool-hotspot" title="핫스팟 추가 (스케치업 뷰에서 클릭)">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="3"></circle>
            <line x1="12" y1="2" x2="12" y2="6"></line>
            <line x1="12" y1="18" x2="12" y2="22"></line>
            <line x1="2" y1="12" x2="6" y2="12"></line>
            <line x1="18" y1="12" x2="22" y2="12"></line>
          </svg>
        </button>
        <span class="mix-tool-label">Click on SketchUp viewport to add hotspot</span>
      </div>

      <!-- Inpaint/Material 모드 툴바 -->
      <div class="mix-toolbar-group hidden" id="mix-toolbar-mask">
        <button class="mix-tool-btn active" id="mix-tool-brush" title="브러시">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M9.06 11.9l8.07-8.06a2.85 2.85 0 1 1 4.03 4.03l-8.06 8.08"></path>
            <path d="M7.07 14.94c-1.66 0-3 1.35-3 3.02 0 1.33-2.5 1.52-2 2.02 1.08 1.1 2.49 2.02 4 2.02 2.2 0 4-1.8 4-4.04a3.01 3.01 0 0 0-3-3.02z"></path>
          </svg>
        </button>
        <button class="mix-tool-btn" id="mix-tool-eraser" title="지우개">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M20 20H7L3 16l10-10 7 7-4 4"></path>
          </svg>
        </button>
        <div class="mix-tool-divider"></div>
        <button class="mix-tool-btn" id="mix-tool-clear-mask" title="마스크 초기화">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="3 6 5 6 21 6"></polyline>
            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
          </svg>
        </button>
      </div>

      <!-- Floorplan 모드 툴바 -->
      <div class="mix-toolbar-group hidden" id="mix-toolbar-floorplan">
        <span class="mix-tool-label">Upload 2D floorplan to generate isometric view</span>
      </div>
    </div>

    <div class="mix-canvas-container">
      <div class="mix-empty-state" id="mix-empty-state">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
          <circle cx="8.5" cy="8.5" r="1.5"></circle>
          <polyline points="21 15 16 10 5 21"></polyline>
        </svg>
        <p>먼저 메인 화면에서 씬을 캡처(Convert)하세요</p>
        <p style="margin-top:4px;color:#555;">캡처 후 Mix 기능을 사용할 수 있습니다</p>
      </div>
      <div class="mix-canvas-wrapper hidden" id="mix-canvas-wrapper">
        <canvas id="mix-main-canvas"></canvas>
        <canvas id="mix-mask-canvas" class="mix-overlay-canvas"></canvas>
        <canvas id="mix-draw-canvas" class="mix-overlay-canvas"></canvas>
      </div>

      <div class="mix-coord-overlay" id="mix-coord-overlay">
        <div>World: <span id="mix-coord-world">X: 0 Y: 0 Z: 0</span></div>
        <div>Screen: <span id="mix-coord-screen">X: 0 Y: 0</span></div>
      </div>

      <div class="mix-loading-overlay hidden" id="mix-loading">
        <div class="spinner"></div>
        <div class="loading-text" id="mix-loading-text">Processing...</div>
        <div class="loading-subtext" id="mix-loading-subtext">AI가 씬을 분석하고 있습니다</div>
      </div>
    </div>

    <div class="mix-status-bar">
      <span id="mix-status-text">Ready</span>
      <span id="mix-scene-info">Scene context loaded</span>
    </div>
  </main>

  <!-- 설정 메인 영역 -->
  <main class="main-area settings-main-area" id="settings-main-area" style="display:none;">
    <div class="settings-container">
      <div class="settings-header">
        <h2>Settings</h2>
        <button class="settings-close-btn" id="btn-close-settings">✕</button>
      </div>
      <div class="settings-content">
        <div class="settings-section">
          <label class="settings-label">Google Gemini API Key</label>
          <div class="settings-input-row">
            <input type="password" id="settings-api-key" class="settings-input" placeholder="API Key를 입력하세요">
            <button class="settings-toggle-btn" id="btn-toggle-api-key">👁️</button>
          </div>
          <p class="settings-help">API Key는 <a href="https://aistudio.google.com/apikey" target="_blank">Google AI Studio</a>에서 발급받을 수 있습니다.</p>
        </div>
        <div class="settings-section">
          <label class="settings-label">연결 상태</label>
          <div class="settings-status">
            <span class="settings-status-dot" id="settings-status-dot"></span>
            <span id="settings-status-text">확인 필요</span>
          </div>
          <button class="settings-btn" id="btn-test-api">🔗 연결 테스트</button>
        </div>
        <div class="settings-actions">
          <button class="settings-btn settings-btn-primary" id="btn-save-settings">저장</button>
        </div>
      </div>
    </div>
  </main>

  <!-- 우측 메인 영역 -->
  <main class="main-area" id="render-main-area">
    <!-- 씬 탭 바 -->
    <div class="scene-tabs" id="scene-tabs">
      <button class="scene-add-btn" id="btn-add-scene" title="현재 뷰를 씬으로 저장">+</button>
    </div>

    <div class="image-container" id="image-container">
      <div class="image-panel" id="source-panel">
        <div class="panel-label">
          <span>Source</span>
          <button class="panel-guide-btn" id="btn-guide" title="가이드 표시">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <line x1="12" y1="2" x2="12" y2="22"></line>
              <line x1="2" y1="12" x2="22" y2="12"></line>
            </svg>
          </button>
          <button class="panel-expand-btn" id="btn-expand-source" title="Expand">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polyline points="15 3 21 3 21 9"></polyline>
              <polyline points="9 21 3 21 3 15"></polyline>
              <line x1="21" y1="3" x2="14" y2="10"></line>
              <line x1="3" y1="21" x2="10" y2="14"></line>
            </svg>
          </button>
        </div>
        <div class="panel-content">
          <div class="empty-state" id="original-empty">No image</div>
          <div class="image-zoom-container" id="zoom-container-source">
            <div class="image-zoom-wrapper" id="zoom-wrapper-source">
              <img id="original-image" style="display:none;">
              <canvas class="guide-grid-canvas" id="guide-canvas-source" style="display:none;"></canvas>
            </div>
          </div>
          <div class="guide-controls hidden" id="guide-controls-source">
            <label>Grid</label>
            <input type="range" class="guide-slider" id="guide-slider-source" min="10" max="100" value="40">
            <span class="guide-value" id="guide-value-source">40px</span>
            <button class="guide-lock-btn" id="guide-lock-source" title="Lock">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
              </svg>
            </button>
            <label style="margin-left:8px;">Zoom</label>
            <input type="range" class="guide-zoom-slider" id="guide-zoom-source" min="50" max="150" value="100">
          </div>
          <div class="loading-overlay hidden" id="loading-source">
            <div class="loading-spinner"></div>
            <div class="loading-text" id="loading-text-source">Converting... <span id="loading-percent-source">0%</span></div>
            <div class="loading-subtext" id="loading-subtext-source">Preparing</div>
            <div class="loading-progress"><div class="loading-progress-bar" id="loading-bar-source"></div></div>
          </div>
        </div>
        <div class="prompt-area" id="prompt-area-source">
          <div class="prompt-header">
            <div class="prompt-tabs">
              <button class="prompt-tab active" data-tab="main">Prompt</button>
              <button class="prompt-tab negative" data-tab="negative">Negative</button>
            </div>
            <button class="prompt-auto-btn" id="btn-auto-prompt" title="AI 자동 생성" disabled>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 2L2 7l10 5 10-5-10-5z"></path>
                <path d="M2 17l10 5 10-5"></path>
                <path d="M2 12l10 5 10-5"></path>
              </svg>
              Auto
            </button>
          </div>
          <div class="prompt-content active" data-content="main">
            <div class="prompt-input-wrapper">
              <textarea id="prompt-source" placeholder="Convert 후 직접 입력하거나 Auto 버튼으로 자동 생성하세요." disabled></textarea>
              <div class="prompt-btn-group">
                <button class="prompt-attach-btn" id="btn-attach-source" title="이미지 첨부" disabled>
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                    <circle cx="8.5" cy="8.5" r="1.5"></circle>
                    <polyline points="21 15 16 10 5 21"></polyline>
                  </svg>
                </button>
                <button class="prompt-generate-btn" id="btn-generate-source" title="이미지 생성" disabled>
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
                  </svg>
                </button>
              </div>
            </div>
          </div>
          <div class="prompt-content" data-content="negative">
            <div class="prompt-input-wrapper">
              <textarea id="prompt-source-negative" class="negative" placeholder="생성 금지 항목 (네거티브 프롬프트)" disabled></textarea>
            </div>
          </div>
        </div>
      </div>

      <div class="image-panel result-panel" id="result-panel-1" data-result-index="1">
        <div class="panel-label">
          <span>Result 1</span>
          <button class="panel-guide-btn" id="btn-guide-result" title="가이드 표시">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <line x1="12" y1="2" x2="12" y2="22"></line>
              <line x1="2" y1="12" x2="22" y2="12"></line>
            </svg>
          </button>
          <button class="panel-expand-btn" id="btn-expand-result" title="Expand">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polyline points="15 3 21 3 21 9"></polyline>
              <polyline points="9 21 3 21 3 15"></polyline>
              <line x1="21" y1="3" x2="14" y2="10"></line>
              <line x1="3" y1="21" x2="10" y2="14"></line>
            </svg>
          </button>
        </div>
        <div class="panel-content">
          <div class="empty-state" id="render-empty">Ready</div>
          <!-- 이미지+그리드 줌 컨테이너 -->
          <div class="image-zoom-container" id="zoom-container-result">
            <div class="image-zoom-wrapper" id="zoom-wrapper-result">
              <img id="render-image" style="display:none;">
              <canvas class="guide-grid-canvas" id="guide-canvas-result" style="display:none;"></canvas>
            </div>
          </div>
          <!-- 그리드 컨트롤 -->
          <div class="guide-controls hidden" id="guide-controls-result">
            <label>Grid</label>
            <input type="range" class="guide-slider" id="guide-slider-result" min="10" max="100" value="40">
            <span class="guide-value" id="guide-value-result">40px</span>
            <button class="guide-lock-btn" id="guide-lock-result" title="Lock">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
              </svg>
            </button>
            <label style="margin-left:8px;">Zoom</label>
            <input type="range" class="guide-zoom-slider" id="guide-zoom-result" min="50" max="150" value="100">
          </div>
          <div class="loading-overlay hidden" id="loading">
            <div class="loading-spinner"></div>
            <div class="loading-text" id="loading-text">Generating...</div>
            <div class="loading-subtext">AI rendering in progress</div>
            <div class="loading-progress"><div class="loading-progress-bar"></div></div>
          </div>
        </div>
        <div class="prompt-area" id="prompt-area-result">
          <div class="prompt-header">
            <div class="prompt-tabs">
              <button class="prompt-tab active" data-tab="main">Prompt</button>
              <button class="prompt-tab negative" data-tab="negative">Negative</button>
            </div>
            <button class="prompt-auto-btn" id="btn-auto-prompt-result" title="AI 자동 생성" disabled>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 2L2 7l10 5 10-5-10-5z"></path>
                <path d="M2 17l10 5 10-5"></path>
                <path d="M2 12l10 5 10-5"></path>
              </svg>
              Auto
            </button>
          </div>
          <div class="prompt-content active" data-content="main">
            <div class="prompt-input-wrapper">
              <textarea id="prompt-result" placeholder="렌더링 완료 후 2차 생성용 프롬프트를 입력하세요." disabled></textarea>
              <div class="prompt-btn-group">
                <button class="prompt-attach-btn" id="btn-attach-result" title="이미지 첨부" disabled>
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                    <circle cx="8.5" cy="8.5" r="1.5"></circle>
                    <polyline points="21 15 16 10 5 21"></polyline>
                  </svg>
                </button>
                <button class="prompt-generate-btn" id="btn-regenerate-1" title="2차 생성" disabled>
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
                  </svg>
                </button>
              </div>
            </div>
          </div>
          <div class="prompt-content" data-content="negative">
            <div class="prompt-input-wrapper">
              <textarea id="prompt-result-negative" class="negative" placeholder="2차 생성 네거티브 프롬프트" disabled></textarea>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="status-bar">
      <span id="status-text">Ready</span>
    </div>

  </main>

  <!-- ========================================
       Node Editor Mode - VizMaker Style
       ======================================== -->
  <div class="node-editor-container" id="node-editor-container">
    <!-- 캔버스 Wrapper (캔버스 + Inspector) -->
    <div class="node-canvas-wrapper">
      <!-- 노드 캔버스 -->
      <div class="node-canvas-area" id="node-canvas-area">
        <div class="node-canvas-grid"></div>
        <svg class="node-connections" id="node-connections"></svg>
        <div class="node-canvas" id="node-canvas">
          <!-- 노드들이 여기에 동적으로 추가됨 -->
        </div>

        <!-- 상단 버튼 -->
        <div class="node-canvas-topbar">
          <button class="node-canvas-btn" id="node-add-source" title="Add Source">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="3" y="3" width="18" height="18" rx="2"/>
              <line x1="12" y1="8" x2="12" y2="16"/>
              <line x1="8" y1="12" x2="16" y2="12"/>
            </svg>
            Source
          </button>
          <button class="node-canvas-btn" id="node-add-renderer" title="Add Renderer">
            <svg viewBox="0 0 24 24" fill="currentColor" style="width:12px;height:12px;">
              <path d="M.968 9.027l7.717 4.428-.006 1.32-4.39-2.518-2.763 1.57 7.148 4.12.005 1.27-7.658-4.405c.02.516.488 2.106 1.383 3.337.91 1.247 1.946 1.776 1.946 1.776L11.428 24V11.849L.975 5.846zm22.064-3.8L15.22.723S13.982 0 12.008 0C9.952 0 8.76.746 8.76.746l-7.236 4.14 11.009 6.328V24l7.245-4.136s1.295-.715 2.279-2.414c.867-1.496.975-2.943.975-2.943z"/>
            </svg>
            Renderer
          </button>
          <button class="node-canvas-btn" id="node-delete" title="Delete Selected">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polyline points="3 6 5 6 21 6"/>
              <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
            </svg>
          </button>
          <button class="node-canvas-btn" id="node-fit" title="Fit View">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7"/>
            </svg>
          </button>
        </div>
      </div>

      <!-- 노드 Inspector 패널 - VizMaker Style -->
      <aside class="node-inspector" id="node-inspector">
        <!-- Preview 영역 -->
        <div class="node-inspector-preview">
          <div class="node-inspector-tabs">
            <button class="node-inspector-tab active" data-tab="preview">Preview</button>
            <button class="node-inspector-tab" data-tab="compare">Compare</button>
          </div>
          <div class="node-inspector-preview-image" id="node-preview-image">
            <span class="node-inspector-preview-empty">No preview</span>
          </div>
          <div class="node-inspector-preview-progress">
            <div class="node-inspector-preview-progress-bar" id="node-preview-progress"></div>
          </div>
        </div>

        <!-- 노드 미선택 시 -->
        <div class="node-inspector-empty" id="node-inspector-empty">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M18 3C19.6569 3 21 4.34315 21 6C21 7.65685 19.6569 9 18 9H15C13.6941 9 12.5831 8.16562 12.171 7.0009L11 7C9.9 7 9 7.9 9 9L9.0009 9.17102C10.1656 9.58312 11 10.6941 11 12C11 13.3059 10.1656 14.4169 9.0009 14.829L9 15C9 16.1 9.9 17 11 17L12.1707 17.0001C12.5825 15.8349 13.6937 15 15 15H18C19.6569 15 21 16.3431 21 18C21 19.6569 19.6569 21 18 21H15C13.6941 21 12.5831 20.1656 12.171 19.0009L11 19C8.79 19 7 17.21 7 15H5C3.34315 15 2 13.6569 2 12C2 10.3431 3.34315 9 5 9H7C7 6.79086 8.79086 5 11 5L12.1707 5.00009C12.5825 3.83485 13.6937 3 15 3H18Z"/>
          </svg>
          <div>Select a node to edit</div>
          <div style="font-size: 11px; margin-top: 8px;">Click on a node or add a new one</div>
        </div>

        <!-- Inspector 컨텐츠 (스크롤 영역) -->
        <div class="node-inspector-content" id="node-inspector-content">
          <!-- Source 노드 Inspector -->
          <div class="hidden" id="inspector-source">
            <!-- Camera 아코디언 -->
            <div class="node-inspector-accordion open">
              <div class="node-inspector-accordion-header">
                <div class="node-inspector-accordion-icon">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                    <circle cx="12" cy="13" r="4"/>
                  </svg>
                </div>
                <span class="node-inspector-accordion-title">Camera</span>
                <div class="node-inspector-accordion-toggle">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="6 9 12 15 18 9"/>
                  </svg>
                </div>
              </div>
              <div class="node-inspector-accordion-body">
                <div class="control-section">
                  <span class="section-label">View</span>
                  <div class="dropdown-selected" id="node-source-view">Current View</div>
                </div>
              </div>
            </div>

            <!-- Time & Lighting 아코디언 -->
            <div class="node-inspector-accordion open">
              <div class="node-inspector-accordion-header">
                <div class="node-inspector-accordion-icon">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="5"/>
                    <line x1="12" y1="1" x2="12" y2="3"/>
                    <line x1="12" y1="21" x2="12" y2="23"/>
                    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                  </svg>
                </div>
                <span class="node-inspector-accordion-title">Time & Lighting</span>
                <div class="node-inspector-accordion-toggle">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="6 9 12 15 18 9"/>
                  </svg>
                </div>
              </div>
              <div class="node-inspector-accordion-body">
                <div class="control-section">
                  <span class="section-label">Time</span>
                  <div class="segmented">
                    <button class="seg-btn active" data-time="day">Day</button>
                    <button class="seg-btn" data-time="sunset">Sunset</button>
                    <button class="seg-btn" data-time="night">Night</button>
                  </div>
                </div>
                <div class="control-section">
                  <span class="section-label">Lights</span>
                  <div class="segmented">
                    <button class="seg-btn active" data-light="on">On</button>
                    <button class="seg-btn" data-light="off">Off</button>
                  </div>
                </div>
              </div>
            </div>

            <!-- Capture 버튼 -->
            <div style="padding: 16px;">
              <button class="btn btn-primary" id="node-source-capture" style="width: 100%;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;margin-right:6px;">
                  <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                  <circle cx="12" cy="13" r="4"/>
                </svg>
                Capture View
              </button>
            </div>
          </div>

          <!-- Renderer 노드 Inspector -->
          <div class="hidden" id="inspector-renderer">
            <!-- Render Settings 아코디언 -->
            <div class="node-inspector-accordion open">
              <div class="node-inspector-accordion-header">
                <div class="node-inspector-accordion-icon">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="3"/>
                    <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
                  </svg>
                </div>
                <span class="node-inspector-accordion-title">Render Settings</span>
                <div class="node-inspector-accordion-toggle">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="6 9 12 15 18 9"/>
                  </svg>
                </div>
              </div>
              <div class="node-inspector-accordion-body">
                <div class="control-section">
                  <span class="section-label">Render Mode</span>
                  <div class="dropdown-selected" id="node-render-mode">Nanobanana Pro</div>
                </div>
                <div class="control-section">
                  <span class="section-label">Resolution</span>
                  <div class="segmented">
                    <button class="seg-btn" data-res="1024">1K</button>
                    <button class="seg-btn active" data-res="2048">2K</button>
                    <button class="seg-btn" data-res="4096">4K</button>
                  </div>
                </div>
                <div class="control-section">
                  <span class="section-label">Aspect Ratio</span>
                  <div class="segmented">
                    <button class="seg-btn active" data-aspect="original">Original</button>
                    <button class="seg-btn" data-aspect="16:9">16:9</button>
                    <button class="seg-btn" data-aspect="1:1">1:1</button>
                  </div>
                </div>
              </div>
            </div>

            <!-- Prompt Presets 아코디언 -->
            <div class="node-inspector-accordion open">
              <div class="node-inspector-accordion-header">
                <div class="node-inspector-accordion-icon">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="4" y1="21" x2="4" y2="14"/>
                    <line x1="4" y1="10" x2="4" y2="3"/>
                    <line x1="12" y1="21" x2="12" y2="12"/>
                    <line x1="12" y1="8" x2="12" y2="3"/>
                    <line x1="20" y1="21" x2="20" y2="16"/>
                    <line x1="20" y1="12" x2="20" y2="3"/>
                  </svg>
                </div>
                <span class="node-inspector-accordion-title">Prompt Presets</span>
                <div class="node-inspector-accordion-toggle">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="6 9 12 15 18 9"/>
                  </svg>
                </div>
              </div>
              <div class="node-inspector-accordion-body">
                <div class="prompt-presets-grid">
                  <button class="prompt-preset-btn" data-preset="realism">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                      <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/>
                    </svg>
                    <span>Realism</span>
                  </button>
                  <button class="prompt-preset-btn" data-preset="closeup">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                      <circle cx="11" cy="11" r="8"/>
                      <line x1="21" y1="21" x2="16.65" y2="16.65"/>
                      <line x1="11" y1="8" x2="11" y2="14"/>
                      <line x1="8" y1="11" x2="14" y2="11"/>
                    </svg>
                    <span>Closeup</span>
                  </button>
                  <button class="prompt-preset-btn" data-preset="day-night">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                      <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                    </svg>
                    <span>Day→Night</span>
                  </button>
                  <button class="prompt-preset-btn" data-preset="night-day">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                      <circle cx="12" cy="12" r="5"/>
                      <line x1="12" y1="1" x2="12" y2="3"/>
                      <line x1="12" y1="21" x2="12" y2="23"/>
                    </svg>
                    <span>Night→Day</span>
                  </button>
                  <button class="prompt-preset-btn" data-preset="brighter">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                      <circle cx="12" cy="12" r="5"/>
                      <line x1="12" y1="1" x2="12" y2="3"/>
                      <line x1="21" y1="12" x2="23" y2="12"/>
                    </svg>
                    <span>Brighter</span>
                  </button>
                  <button class="prompt-preset-btn" data-preset="volumetric">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                      <path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"/>
                    </svg>
                    <span>Volumetric</span>
                  </button>
                  <button class="prompt-preset-btn" data-preset="fog">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                      <line x1="3" y1="8" x2="21" y2="8"/>
                      <line x1="3" y1="12" x2="21" y2="12"/>
                      <line x1="3" y1="16" x2="21" y2="16"/>
                    </svg>
                    <span>Fog</span>
                  </button>
                  <button class="prompt-preset-btn" data-preset="people">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                      <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                      <circle cx="9" cy="7" r="4"/>
                    </svg>
                    <span>People</span>
                  </button>
                </div>
              </div>
            </div>

            <!-- Custom Prompt 아코디언 -->
            <div class="node-inspector-accordion">
              <div class="node-inspector-accordion-header">
                <div class="node-inspector-accordion-icon">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="17" y1="10" x2="3" y2="10"/>
                    <line x1="21" y1="6" x2="3" y2="6"/>
                    <line x1="21" y1="14" x2="3" y2="14"/>
                    <line x1="17" y1="18" x2="3" y2="18"/>
                  </svg>
                </div>
                <span class="node-inspector-accordion-title">Custom Prompt</span>
                <div class="node-inspector-accordion-toggle">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="6 9 12 15 18 9"/>
                  </svg>
                </div>
              </div>
              <div class="node-inspector-accordion-body">
                <textarea class="prompt-input" id="node-custom-prompt" placeholder="Enter custom prompt..." style="width:100%;min-height:80px;background:#0d1117;border:1px solid #30363d;border-radius:6px;padding:10px;color:#e6edf3;font-size:11px;resize:vertical;"></textarea>
              </div>
            </div>
          </div>
        </div>
      </aside>
    </div><!-- .node-canvas-wrapper -->

    <!-- 하단 프롬프트 바 - VizMaker Style -->
    <div class="node-bottom-bar">
      <div class="node-bottom-prompt">
        <input type="text" class="node-prompt-input" id="node-prompt-input" placeholder="Enter prompt or select presets above...">
      </div>
      <button class="node-make-btn" id="node-make-btn">
        <svg viewBox="0 0 24 24" fill="currentColor">
          <path d="M13 10V3L4 14h7v7l9-11h-7z"/>
        </svg>
        Make
      </button>
    </div>
  </div>

  <script>
    const state = {
      originalImage: null,
      renderImage: null,
      isRendering: false,
      apiConnected: false,
      converted: false,  // Convert 완료 여부
      timePreset: 'day',
      lightSwitch: 'on',
      imageSize: '1024',  // ★ 속도 우선 (1024px)
      engine: 'replicate',  // ★ Replicate 기본 (구도 유지)
      resultPanels: [{ id: 1, image: null }],  // 결과 패널 목록
      nextResultId: 2,
      currentScene: null,  // 현재 활성 씬 이름
      history: [],  // 히스토리 배열
      nextHistoryId: 1
    };

    // 씬별 상태 저장소
    const sceneStates = new Map();

    // 현재 씬 상태 저장
    function saveCurrentSceneState() {
      if (!state.currentScene) return;

      const promptSource = document.getElementById('prompt-source');
      const promptSourceNegative = document.getElementById('prompt-source-negative');
      const promptResult = document.getElementById('prompt-result');
      const promptResultNegative = document.getElementById('prompt-result-negative');

      sceneStates.set(state.currentScene, {
        originalImage: state.originalImage,
        renderImage: state.renderImage,
        converted: state.converted,
        promptSource: promptSource?.value || '',
        promptSourceNegative: promptSourceNegative?.value || '',
        promptResult: promptResult?.value || '',
        promptResultNegative: promptResultNegative?.value || '',
        resultPanels: JSON.parse(JSON.stringify(state.resultPanels)),
        nextResultId: state.nextResultId
      });

      console.log('[NanoBanana] 씬 상태 저장:', state.currentScene, 'Result 이미지:', state.resultPanels[0]?.image ? '있음' : '없음');
    }

    // 씬 상태 복원 (el 객체 초기화 후 호출됨)
    function restoreSceneState(sceneName) {
      const savedState = sceneStates.get(sceneName);

      const originalImage = document.getElementById('original-image');
      const originalEmpty = document.getElementById('original-empty');
      const renderImage = document.getElementById('render-image');
      const renderEmpty = document.getElementById('render-empty');
      const btnRender = document.getElementById('btn-generate-source');
      const btnEdit = document.getElementById('btn-edit');
      const btnSave = document.getElementById('btn-save');
      const promptSource = document.getElementById('prompt-source');
      const promptSourceNegative = document.getElementById('prompt-source-negative');
      const promptResult = document.getElementById('prompt-result');
      const promptResultNegative = document.getElementById('prompt-result-negative');

      if (savedState) {
        // 저장된 상태 복원
        state.originalImage = savedState.originalImage;
        state.renderImage = savedState.renderImage;
        state.converted = savedState.converted;
        state.resultPanels = savedState.resultPanels;
        state.nextResultId = savedState.nextResultId;

        // UI 복원 - SOURCE 이미지
        if (savedState.originalImage && originalImage) {
          originalImage.src = 'data:image/png;base64,' + savedState.originalImage;
          originalImage.style.display = 'block';
          if (originalEmpty) originalEmpty.style.display = 'none';
        } else {
          if (originalImage) originalImage.style.display = 'none';
          if (originalEmpty) originalEmpty.style.display = 'flex';
        }

        // UI 복원 - RESULT 이미지 (첫번째 resultPanel 사용)
        const firstResult = savedState.resultPanels && savedState.resultPanels[0];
        if (firstResult && firstResult.image && renderImage) {
          renderImage.src = 'data:image/png;base64,' + firstResult.image;
          renderImage.style.display = 'block';
          if (renderEmpty) renderEmpty.style.display = 'none';
          if (btnEdit) btnEdit.disabled = false;
          if (btnSave) btnSave.disabled = false;
        } else if (savedState.renderImage && renderImage) {
          renderImage.src = 'data:image/png;base64,' + savedState.renderImage;
          renderImage.style.display = 'block';
          if (renderEmpty) renderEmpty.style.display = 'none';
          if (btnEdit) btnEdit.disabled = false;
          if (btnSave) btnSave.disabled = false;
        } else {
          if (renderImage) renderImage.style.display = 'none';
          if (renderEmpty) renderEmpty.style.display = 'flex';
          if (btnEdit) btnEdit.disabled = true;
          if (btnSave) btnSave.disabled = true;
        }

        // UI 복원 - 프롬프트
        if (promptSource) promptSource.value = savedState.promptSource || '';
        if (promptSourceNegative) promptSourceNegative.value = savedState.promptSourceNegative || '';
        if (promptResult) promptResult.value = savedState.promptResult || '';
        if (promptResultNegative) promptResultNegative.value = savedState.promptResultNegative || '';

        // Render 버튼 상태
        if (btnRender) btnRender.disabled = !savedState.originalImage || !savedState.promptSource;

        console.log('[NanoBanana] 씬 상태 복원:', sceneName, 'Result 이미지:', firstResult?.image ? '있음' : '없음');
      } else {
        // 새 씬 - 초기 상태로
        state.originalImage = null;
        state.renderImage = null;
        state.converted = false;
        state.resultPanels = [{ id: 1, image: null }];
        state.nextResultId = 2;

        if (originalImage) originalImage.style.display = 'none';
        if (originalEmpty) originalEmpty.style.display = 'flex';
        if (renderImage) renderImage.style.display = 'none';
        if (renderEmpty) renderEmpty.style.display = 'flex';

        if (promptSource) promptSource.value = '';
        if (promptSourceNegative) promptSourceNegative.value = '';
        if (promptResult) promptResult.value = '';
        if (promptResultNegative) promptResultNegative.value = '';

        if (btnRender) btnRender.disabled = true;
        if (btnEdit) btnEdit.disabled = true;
        if (btnSave) btnSave.disabled = true;

        console.log('[NanoBanana] 새 씬 초기화:', sceneName);
      }

      state.currentScene = sceneName;
    }

    // 씬 전환 처리 (Ruby에서 호출)
    window.onSceneChanged = function(sceneName) {
      // 현재 씬 상태 저장
      saveCurrentSceneState();
      // 새 씬 상태 복원
      restoreSceneState(sceneName);
      console.log('[NanoBanana] Scene changed to:', sceneName);
    };

    const el = {
      originalImage: document.getElementById('original-image'),
      originalEmpty: document.getElementById('original-empty'),
      renderImage: document.getElementById('render-image'),
      renderEmpty: document.getElementById('render-empty'),
      loading: document.getElementById('loading'),
      loadingSource: document.getElementById('loading-source'),
      btnCapture: document.getElementById('btn-capture'),
      btnRender: document.getElementById('btn-generate-source'),
      btnEdit: document.getElementById('btn-edit'),
      btnSave: document.getElementById('btn-save'),
      btnSettings: document.getElementById('btn-settings'),
      btnAutoPrompt: document.getElementById('btn-auto-prompt'),
      btnAttachSource: document.getElementById('btn-attach-source'),
      btnGenerateSource: document.getElementById('btn-generate-source'),
      statusText: document.getElementById('status-text'),
      statusDot: document.getElementById('status-dot'),
      apiStatus: document.getElementById('api-status'),
      promptSource: document.getElementById('prompt-source'),
      promptSourceNegative: document.getElementById('prompt-source-negative'),
      promptResult: document.getElementById('prompt-result'),
      promptResultNegative: document.getElementById('prompt-result-negative'),
      btnAutoPromptResult: document.getElementById('btn-auto-prompt-result'),
      btnRegenerateResult: document.getElementById('btn-regenerate-1')
    };

    // 프롬프트 탭 전환
    document.querySelectorAll('.prompt-area').forEach(area => {
      area.querySelectorAll('.prompt-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          const tabName = tab.dataset.tab;
          // 탭 활성화
          area.querySelectorAll('.prompt-tab').forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          // 컨텐츠 활성화
          area.querySelectorAll('.prompt-content').forEach(c => c.classList.remove('active'));
          area.querySelector(`.prompt-content[data-content="${tabName}"]`).classList.add('active');
        });
      });
    });

    // SketchUp Ruby 콜백 호출
    function callRuby(action, ...args) {
      // skp: 프로토콜만 사용 (가장 안정적)
      const param = args.length > 0 ? JSON.stringify(args) : '';
      window.location = 'skp:' + action + '@' + encodeURIComponent(param);
    }

    const sketchup = {
      captureScene: (size) => callRuby('capture_scene', size),
      startRender: (time, light, prompt, negativePrompt) => callRuby('start_render', time, light, prompt, negativePrompt),
      generateAutoPrompt: (style, time, light) => callRuby('generate_auto_prompt', style || '', time || 'day', light || 'on'),
      saveImage: () => callRuby('save_image', ''),
      openEditor: () => callRuby('open_editor'),
      checkApiStatus: () => callRuby('check_api_status'),
      // Gemini API Key
      saveApiKey: (key) => callRuby('save_api_key', key),
      loadApiKey: () => callRuby('load_api_key'),
      testConnection: () => callRuby('test_connection'),
      // Replicate API
      saveReplicateToken: (token) => callRuby('save_replicate_token', token),
      loadReplicateToken: () => callRuby('load_replicate_token'),
      // Engine selection
      setEngine: (engine) => callRuby('set_engine', engine),
      getEngine: () => callRuby('get_engine'),
      // Model selection
      saveModel: (model) => callRuby('save_model', model),
      loadModel: () => callRuby('load_model'),
      // Camera controls
      camMove: (dir) => callRuby('cam_move', dir),
      camRotate: (dir) => callRuby('cam_rotate', dir),
      camHeight: (preset) => callRuby('cam_height', preset),
      camFov: (preset) => callRuby('cam_fov', preset),
      startMirror: () => callRuby('start_mirror'),
      stopMirror: () => callRuby('stop_mirror'),
      // Scene controls
      getScenes: () => callRuby('get_scenes'),
      selectScene: (name) => callRuby('select_scene', name),
      addScene: () => callRuby('add_scene'),
      // 2점 투시
      apply2Point: () => callRuby('apply_2point'),
      // Mix - 선택된 패널의 이미지 전달
      openMix: (imageBase64) => callRuby('open_mix', imageBase64),
      // 2차 생성 (소스 이미지 base64, 프롬프트, 대상 패널 ID)
      regenerate: (sourceBase64, prompt, panelId) => callRuby('regenerate', sourceBase64, prompt, panelId),
      // 히스토리
      loadHistory: () => callRuby('load_history'),
      saveHistory: (json) => callRuby('save_history', json)
    };

    let mirrorActive = false;
    let selectedPanel = 'source'; // 'source' or 'result'

    // 패널 선택 기능
    function selectPanel(panelType) {
      selectedPanel = panelType;

      // 모든 패널에서 selected 클래스 제거
      document.querySelectorAll('.image-panel').forEach(p => p.classList.remove('selected'));

      // 선택된 패널에 selected 클래스 추가
      if (panelType === 'source') {
        document.getElementById('source-panel').classList.add('selected');
      } else {
        document.getElementById('result-panel-1').classList.add('selected');
      }
    }

    // 선택된 패널의 이미지 가져오기
    function getSelectedImage() {
      if (selectedPanel === 'source') {
        return state.originalImage;
      } else {
        return state.renderImage;
      }
    }

    function onCaptureComplete(base64, materialCount) {
      // 노드 에디터 콜백이 있으면 우선 처리
      if (window._nodeSourceCallback) {
        window._nodeSourceCallback(base64);
        window._nodeSourceCallback = null;
        return;
      }

      state.originalImage = base64;
      el.originalImage.src = 'data:image/png;base64,' + base64;
      el.originalImage.style.display = 'block';
      el.originalEmpty.style.display = 'none';
      setStatus('Analyzing scene...');
      // Render 버튼은 onConvertComplete에서 활성화
    }

    // Convert 진행 상황 업데이트 (Ruby에서 호출)
    function updateConvertProgress(stage, detail) {
      const loadingText = el.loadingSource.querySelector('.loading-text');
      const loadingSubtext = el.loadingSource.querySelector('.loading-subtext');
      if (loadingText) loadingText.textContent = stage;
      if (loadingSubtext) loadingSubtext.textContent = detail;
      setStatus(stage + ' - ' + detail);
    }

    // Convert 에러 (Ruby에서 호출)
    function onConvertError(errorMsg) {
      stopConvertProgress(false);
      el.btnCapture.disabled = false;
      el.btnCapture.textContent = 'Convert';
      el.loadingSource.classList.add('hidden');
      setStatus('Convert 실패: ' + errorMsg);
    }

    // Convert 완료 (씬 분석 완료 - 프롬프트는 별도)
    function onConvertComplete(promptText) {
      stopConvertProgress(true);
      state.converted = true;
      el.btnCapture.disabled = false;
      el.btnCapture.textContent = 'Convert';

      // 100% 표시 후 로딩 숨김
      setTimeout(() => {
        el.loadingSource.classList.add('hidden');
      }, 500);

      // 프롬프트창 활성화 (비워둠 - 사용자가 직접 입력하거나 Auto 사용)
      el.promptSource.value = '';
      el.promptSource.disabled = false;
      el.promptSource.placeholder = '직접 입력하거나 Auto 버튼으로 자동 생성하세요.';
      el.promptSourceNegative.value = '';
      el.promptSourceNegative.disabled = false;

      // Auto 버튼 및 기타 버튼 활성화
      el.btnAutoPrompt.disabled = false;
      el.btnAttachSource.disabled = false;
      el.btnGenerateSource.disabled = false;

      // Render 버튼은 프롬프트 입력 후 활성화 (또는 Auto 후)
      el.btnRender.disabled = true;

      setStatus('Convert 완료 - 프롬프트를 입력하거나 Auto 생성하세요');
    }

    // Auto 프롬프트 생성 시작
    function onAutoPromptStart() {
      el.btnAutoPrompt.disabled = true;
      el.btnAutoPrompt.classList.add('loading');
      el.btnAutoPrompt.innerHTML = `
        <svg class="spin" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="12" r="10"></circle>
          <path d="M12 6v6l4 2"></path>
        </svg>
        생성중...
      `;

      // SOURCE 영역에 로딩 오버레이 + 프로그레스 바 표시
      el.loadingSource.innerHTML = `
        <div class="auto-prompt-loading">
          <div class="loading-spinner"></div>
          <div class="loading-status">프롬프트 생성 중...</div>
          <div class="loading-detail">씬 분석 및 재질 정보 추출</div>
          <div class="prompt-progress-container">
            <div class="prompt-progress-bar" id="prompt-progress-bar"></div>
          </div>
          <div class="prompt-progress-text" id="prompt-progress-text">0%</div>
        </div>
      `;
      el.loadingSource.classList.remove('hidden');

      // 프로그레스 애니메이션 시작
      startPromptProgress();

      setStatus('Auto 프롬프트 생성 중...');
    }

    // 프롬프트 생성 프로그레스 변수
    let promptProgressInterval = null;
    let promptProgressValue = 0;

    // 프롬프트 생성 프로그레스 시작
    function startPromptProgress() {
      promptProgressValue = 0;
      promptProgressInterval = setInterval(() => {
        // 90%까지만 자동 증가 (완료 시 100%로 점프)
        if (promptProgressValue < 90) {
          promptProgressValue += Math.random() * 8 + 2;
          if (promptProgressValue > 90) promptProgressValue = 90;
          updatePromptProgress(promptProgressValue);
        }
      }, 500);
    }

    // 프롬프트 생성 프로그레스 업데이트
    function updatePromptProgress(value) {
      const bar = document.getElementById('prompt-progress-bar');
      const text = document.getElementById('prompt-progress-text');
      if (bar) bar.style.width = value + '%';
      if (text) text.textContent = Math.round(value) + '%';
    }

    // 프롬프트 생성 프로그레스 정지
    function stopPromptProgress() {
      if (promptProgressInterval) {
        clearInterval(promptProgressInterval);
        promptProgressInterval = null;
      }
      updatePromptProgress(100);
    }

    // Auto 프롬프트 생성 완료
    function onAutoPromptComplete(mainPrompt, negativePrompt) {
      // 프로그레스 100%로 완료
      stopPromptProgress();

      el.btnAutoPrompt.disabled = false;
      el.btnAutoPrompt.classList.remove('loading');
      el.btnAutoPrompt.innerHTML = `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M12 2L2 7l10 5 10-5-10-5z"></path>
          <path d="M2 17l10 5 10-5"></path>
          <path d="M2 12l10 5 10-5"></path>
        </svg>
        Auto
      `;

      // 잠시 후 SOURCE 영역 로딩 해제 (100% 보여주고)
      setTimeout(() => {
        el.loadingSource.innerHTML = '';
        el.loadingSource.classList.add('hidden');
      }, 300);

      // 프롬프트창에 표시
      el.promptSource.value = mainPrompt || '';
      el.promptSourceNegative.value = negativePrompt || '';

      // Render 버튼 활성화
      el.btnRender.disabled = false;

      setStatus('Auto 프롬프트 생성 완료 - Render 가능');
    }

    // Auto 프롬프트 생성 에러
    function onAutoPromptError(errorMsg) {
      // 프로그레스 정지
      if (promptProgressInterval) {
        clearInterval(promptProgressInterval);
        promptProgressInterval = null;
      }

      el.btnAutoPrompt.disabled = false;
      el.btnAutoPrompt.classList.remove('loading');
      el.btnAutoPrompt.innerHTML = `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M12 2L2 7l10 5 10-5-10-5z"></path>
          <path d="M2 17l10 5 10-5"></path>
          <path d="M2 12l10 5 10-5"></path>
        </svg>
        Auto
      `;

      // SOURCE 영역에 에러 표시
      el.loadingSource.innerHTML = `
        <div class="auto-prompt-error">
          <span style="color: #ff6b6b;">프롬프트 생성 실패</span>
          <span style="font-size: 11px; color: #888;">${errorMsg}</span>
        </div>
      `;
      el.loadingSource.classList.remove('hidden');
      // 3초 후 에러 메시지 숨김
      setTimeout(() => {
        el.loadingSource.innerHTML = '';
        el.loadingSource.classList.add('hidden');
      }, 3000);

      setStatus('Auto 프롬프트 실패: ' + errorMsg);
    }

    // 렌더링 중인 씬 목록 관리
    const renderingScenes = new Map(); // sceneName -> { startTime }

    function onRenderStart(sceneName) {
      state.isRendering = true;
      el.loading.classList.remove('hidden');
      // Render 버튼은 활성화 상태 유지 (연속 렌더링 가능)
      // el.btnRender.disabled = true;

      // 해당 씬 탭에 로딩 표시
      if (sceneName) {
        renderingScenes.set(sceneName, { startTime: Date.now() });
        updateSceneTabStatus(sceneName, 'rendering');
      }

      setStatus('Rendering: ' + (sceneName || 'Unknown'));
    }

    function onRenderComplete(base64, sceneName, panelId = 1) {
      // 노드 에디터 콜백이 있으면 우선 처리
      if (window._nodeRendererCallback) {
        window._nodeRendererCallback(base64);
        window._nodeRendererCallback = null;
        return;
      }

      state.renderImage = base64;

      // 해당 패널의 결과 이미지 저장
      const panelData = state.resultPanels.find(p => p.id === panelId);
      if (panelData) panelData.image = base64;

      el.renderImage.src = 'data:image/png;base64,' + base64;
      el.renderImage.style.display = 'block';
      el.renderEmpty.style.display = 'none';
      el.loading.classList.add('hidden');
      el.btnRender.disabled = false;
      el.btnEdit.disabled = false;
      el.btnSave.disabled = false;

      // RESULT 프롬프트 영역 활성화 (2차 생성용)
      el.promptResult.disabled = false;
      el.promptResult.placeholder = '2차 생성용 프롬프트를 입력하세요.';
      el.promptResultNegative.disabled = false;
      el.btnAutoPromptResult.disabled = false;
      el.btnRegenerateResult.disabled = false;

      // 해당 씬 탭 상태 업데이트
      if (sceneName) {
        renderingScenes.delete(sceneName);
        updateSceneTabStatus(sceneName, 'complete');
        // 3초 후 상태 초기화
        setTimeout(() => updateSceneTabStatus(sceneName, 'normal'), 3000);
      }

      // 다른 씬이 아직 렌더링 중인지 확인
      state.isRendering = renderingScenes.size > 0;

      // 히스토리에 추가
      addToHistory(base64, sceneName || 'Unknown');

      setStatus('Complete: ' + (sceneName || 'Unknown'));
    }

    // 히스토리에 추가
    function addToHistory(image, sceneName) {
      const historyItem = {
        id: state.nextHistoryId++,
        image: image,
        scene: sceneName,
        timestamp: Date.now(),
        prompt: el.promptSource?.value || '',
        negativePrompt: el.promptSourceNegative?.value || ''
      };

      state.history.unshift(historyItem);

      // 최대 500개 유지
      if (state.history.length > 500) {
        state.history = state.history.slice(0, 500);
      }

      // 파일에 저장
      sketchup.save_history(JSON.stringify(state.history));

      // 갤러리 업데이트
      renderHistoryGallery();
    }

    // 히스토리 갤러리 렌더링
    function renderHistoryGallery() {
      const gallery = document.getElementById('history-gallery');
      if (!gallery) return;

      gallery.innerHTML = '';

      state.history.forEach(item => {
        const div = document.createElement('div');
        div.className = 'history-item';
        div.innerHTML = `<img src="data:image/png;base64,${item.image}" alt="${item.scene}">`;
        div.onclick = () => loadHistoryItem(item);
        gallery.appendChild(div);
      });
    }

    // 히스토리 아이템 로드
    function loadHistoryItem(item) {
      state.renderImage = item.image;
      el.renderImage.src = 'data:image/png;base64,' + item.image;
      el.renderImage.style.display = 'block';
      el.renderEmpty.style.display = 'none';

      if (item.prompt) el.promptSource.value = item.prompt;
      if (item.negativePrompt) el.promptSourceNegative.value = item.negativePrompt;
    }

    // 히스토리 로드 콜백 (Ruby에서 호출)
    function onHistoryLoaded(historyArray) {
      console.log('[NanoBanana] 히스토리 로드:', historyArray.length, '개');
      state.history = historyArray || [];
      state.nextHistoryId = state.history.length > 0 ? Math.max(...state.history.map(h => h.id || 0)) + 1 : 1;
      renderHistoryGallery();
    }

    function onRenderError(msg, sceneName) {
      el.loading.classList.add('hidden');
      el.btnRender.disabled = false;

      // 해당 씬 탭 상태 업데이트
      if (sceneName) {
        renderingScenes.delete(sceneName);
        updateSceneTabStatus(sceneName, 'error');
        // 5초 후 상태 초기화
        setTimeout(() => updateSceneTabStatus(sceneName, 'normal'), 5000);
      }

      // 다른 씬이 아직 렌더링 중인지 확인
      state.isRendering = renderingScenes.size > 0;

      setStatus('Error: ' + msg);
    }

    // 씬 탭 상태 업데이트
    function updateSceneTabStatus(sceneName, status) {
      const tabs = document.querySelectorAll('.scene-tab');
      tabs.forEach(tab => {
        if (tab.dataset.scene === sceneName) {
          // 기존 상태 클래스 제거
          tab.classList.remove('rendering', 'render-complete', 'render-error');

          // 스피너 제거/추가
          const existingSpinner = tab.querySelector('.scene-tab-spinner');
          if (existingSpinner) existingSpinner.remove();

          if (status === 'rendering') {
            tab.classList.add('rendering');
            // 스피너 추가
            const spinner = document.createElement('div');
            spinner.className = 'scene-tab-spinner';
            tab.insertBefore(spinner, tab.firstChild);
          } else if (status === 'complete') {
            tab.classList.add('render-complete');
          } else if (status === 'error') {
            tab.classList.add('render-error');
          }
        }
      });
    }

    function onApiStatusUpdate(connected) {
      state.apiConnected = connected;
      el.statusDot.classList.toggle('connected', connected);
      el.apiStatus.textContent = connected ? 'Connected' : 'Disconnected';
    }

    // 렌더링 타이머
    let renderStartTime = null;
    let renderTimerInterval = null;
    const loadingText = document.getElementById('loading-text');

    function startRenderTimer() {
      renderStartTime = Date.now();
      if (renderTimerInterval) clearInterval(renderTimerInterval);
      renderTimerInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - renderStartTime) / 1000);
        const mins = Math.floor(elapsed / 60);
        const secs = elapsed % 60;
        const timeStr = mins > 0 ? `${mins}분 ${secs}초` : `${secs}초`;
        el.statusText.textContent = `AI 이미지 생성중... ${timeStr}`;
        if (loadingText) loadingText.textContent = `AI 이미지 생성중... ${timeStr}`;
      }, 1000);
    }

    function stopRenderTimer(finalStatus) {
      if (renderTimerInterval) {
        clearInterval(renderTimerInterval);
        renderTimerInterval = null;
      }
      if (renderStartTime) {
        const elapsed = Math.floor((Date.now() - renderStartTime) / 1000);
        const mins = Math.floor(elapsed / 60);
        const secs = elapsed % 60;
        const timeStr = mins > 0 ? `${mins}분 ${secs}초` : `${secs}초`;
        el.statusText.textContent = finalStatus ? `${finalStatus} (${timeStr})` : `완료 (${timeStr})`;
        renderStartTime = null;
      } else {
        el.statusText.textContent = finalStatus || 'Ready';
      }
    }

    function setStatus(text) {
      // 렌더링 완료/에러 시 타이머 멈추고 상태 표시
      const lowerText = text.toLowerCase();
      if (lowerText.includes('complete') || lowerText.includes('done') || lowerText.includes('error') || lowerText.includes('failed')) {
        stopRenderTimer(text);
      } else if (!renderTimerInterval) {
        el.statusText.textContent = text;
      }
    }

    // Convert 진행률 관리
    let convertProgressInterval = null;
    const convertSteps = [
      { percent: 5, text: 'Preparing', subtext: 'Initializing...' },
      { percent: 15, text: 'Converting', subtext: 'Capturing scene' },
      { percent: 30, text: 'Converting', subtext: 'Processing image' },
      { percent: 50, text: 'Converting', subtext: 'Analyzing scene' },
      { percent: 70, text: 'Converting', subtext: 'Generating prompt' },
      { percent: 85, text: 'Converting', subtext: 'Finalizing' },
      { percent: 95, text: 'Converting', subtext: 'Almost done' }
    ];
    let convertStepIndex = 0;

    function updateConvertProgress(percent, text, subtext) {
      const percentEl = document.getElementById('loading-percent-source');
      const subtextEl = document.getElementById('loading-subtext-source');
      const barEl = document.getElementById('loading-bar-source');

      if (percentEl) percentEl.textContent = percent + '%';
      if (subtextEl) subtextEl.textContent = subtext;
      if (barEl) {
        barEl.classList.remove('indeterminate');
        barEl.style.width = percent + '%';
      }
    }

    function startConvertProgress() {
      convertStepIndex = 0;
      updateConvertProgress(0, 'Converting', 'Preparing');

      convertProgressInterval = setInterval(() => {
        if (convertStepIndex < convertSteps.length) {
          const step = convertSteps[convertStepIndex];
          updateConvertProgress(step.percent, step.text, step.subtext);
          convertStepIndex++;
        }
      }, 800);
    }

    function stopConvertProgress(success = true) {
      if (convertProgressInterval) {
        clearInterval(convertProgressInterval);
        convertProgressInterval = null;
      }
      if (success) {
        updateConvertProgress(100, 'Complete', 'Done!');
      }
    }

    el.btnCapture.addEventListener('click', () => {
      setStatus('Converting...');
      el.btnCapture.disabled = true;
      el.btnCapture.textContent = 'Converting...';
      el.loadingSource.classList.remove('hidden');
      startConvertProgress();
      sketchup.captureScene(state.imageSize);
    });

    el.btnRender.addEventListener('click', () => {
      startRenderTimer();
      const prompt = el.promptSource.value || '';
      const negativePrompt = el.promptSourceNegative.value || '';
      sketchup.startRender(state.timePreset, state.lightSwitch, prompt, negativePrompt);
    });

    // Auto 프롬프트 버튼 - 바로 생성 (현재 라이팅 설정 전달)
    el.btnAutoPrompt.addEventListener('click', () => {
      sketchup.generateAutoPrompt('', state.timePreset, state.lightSwitch);
    });

    // 프롬프트 입력 시 Render 버튼 활성화
    el.promptSource.addEventListener('input', () => {
      if (state.converted && el.promptSource.value.trim()) {
        el.btnRender.disabled = false;
      } else if (state.converted) {
        el.btnRender.disabled = true;
      }
    });

    el.btnSave.addEventListener('click', () => sketchup.saveImage());
    el.btnEdit.addEventListener('click', () => sketchup.openEditor());
    el.btnSettings.addEventListener('click', () => openSettingsPanel());

    // 설정 화면 열기/닫기
    function openSettingsPanel() {
      document.getElementById('render-main-area').style.display = 'none';
      document.getElementById('settings-main-area').style.display = 'flex';
      sketchup.loadApiKey();
    }

    function closeSettingsPanel() {
      document.getElementById('settings-main-area').style.display = 'none';
      document.getElementById('render-main-area').style.display = 'flex';
    }

    // 설정 화면 이벤트
    document.getElementById('btn-close-settings').addEventListener('click', closeSettingsPanel);

    document.getElementById('btn-toggle-api-key').addEventListener('click', function() {
      const input = document.getElementById('settings-api-key');
      if (input.type === 'password') {
        input.type = 'text';
        this.textContent = '🙈';
      } else {
        input.type = 'password';
        this.textContent = '👁️';
      }
    });

    document.getElementById('btn-test-api').addEventListener('click', function() {
      const input = document.getElementById('settings-api-key');
      const apiKey = input.value.trim();
      const hasStoredKey = input.placeholder && input.placeholder.includes('저장됨');

      // 새로 입력한 키가 없고, 저장된 키도 없으면 에러
      if (!apiKey && !hasStoredKey) {
        document.getElementById('settings-status-dot').className = 'settings-status-dot error';
        document.getElementById('settings-status-text').textContent = 'API Key를 입력하세요';
        return;
      }

      document.getElementById('settings-status-dot').className = 'settings-status-dot testing';
      document.getElementById('settings-status-text').textContent = '테스트 중...';

      // 새 키 입력했으면 저장 후 테스트, 아니면 바로 테스트
      if (apiKey) {
        sketchup.saveApiKey(apiKey);
        setTimeout(() => sketchup.testConnection(), 500);
      } else {
        sketchup.testConnection();
      }
    });

    document.getElementById('btn-save-settings').addEventListener('click', function() {
      const apiKey = document.getElementById('settings-api-key').value.trim();
      if (apiKey) {
        sketchup.saveApiKey(apiKey);
      }
      closeSettingsPanel();
    });

    // Ruby 콜백: API Key 로드 완료
    window.onApiKeyLoaded = function(maskedKey) {
      const input = document.getElementById('settings-api-key');
      const statusDot = document.getElementById('settings-status-dot');
      const statusText = document.getElementById('settings-status-text');

      if (maskedKey && maskedKey.length > 0) {
        input.placeholder = maskedKey + ' (저장됨)';
        input.value = '';
        // API 키가 있으면 연결 상태도 표시
        statusDot.className = 'settings-status-dot success';
        statusText.textContent = '연결됨 (저장된 키 사용중)';
      } else {
        input.placeholder = 'API Key를 입력하세요';
        statusDot.className = 'settings-status-dot error';
        statusText.textContent = 'API Key를 입력하세요';
      }
    };

    // Ruby 콜백: 연결 테스트 결과
    window.onConnectionTestResult = function(success, message) {
      if (success) {
        document.getElementById('settings-status-dot').className = 'settings-status-dot success';
        document.getElementById('settings-status-text').textContent = '연결 성공';
      } else {
        document.getElementById('settings-status-dot').className = 'settings-status-dot error';
        document.getElementById('settings-status-text').textContent = '연결 실패: ' + message;
      }
    };

    // 패널 선택 이벤트
    document.getElementById('source-panel').addEventListener('click', (e) => {
      // 버튼 클릭은 제외
      if (e.target.closest('button')) return;
      selectPanel('source');
    });

    document.getElementById('result-panel-1').addEventListener('click', (e) => {
      // 버튼 클릭은 제외
      if (e.target.closest('button')) return;
      selectPanel('result');
    });

    // 초기 선택: source
    selectPanel('source');

    // RESULT 패널 2차 생성 버튼
    el.btnRegenerateResult.addEventListener('click', () => {
      if (!state.renderImage) return;
      const prompt = el.promptResult.value || el.promptSource.value || '';
      const negativePrompt = el.promptResultNegative.value || el.promptSourceNegative.value || '';
      sketchup.startRender(state.timePreset, state.lightSwitch, prompt, negativePrompt);
    });

    // RESULT Auto 버튼 - 바로 생성 (현재 라이팅 설정 전달)
    el.btnAutoPromptResult.addEventListener('click', () => {
      sketchup.generateAutoPrompt('', state.timePreset, state.lightSwitch);
    });

    document.querySelectorAll('#time-group .seg-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#time-group .seg-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        state.timePreset = btn.dataset.time;
      });
    });

    document.querySelectorAll('#light-group .seg-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#light-group .seg-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        state.lightSwitch = btn.dataset.light;
      });
    });

    // ★ Engine buttons (Gemini / Replicate)
    document.querySelectorAll('#engine-group .seg-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#engine-group .seg-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        state.engine = btn.dataset.engine;
        sketchup.setEngine(btn.dataset.engine);
        // 모델 드롭다운 필터링 (해당 엔진 모델만 표시)
        updateModelDropdownForEngine(btn.dataset.engine);
      });
    });

    // 엔진에 따라 모델 드롭다운 필터링
    function updateModelDropdownForEngine(engine) {
      const items = document.querySelectorAll('#model-dropdown-menu .dropdown-item');
      items.forEach(item => {
        if (item.dataset.engine === engine) {
          item.style.display = 'block';
        } else {
          item.style.display = 'none';
        }
      });
      // 첫 번째 보이는 모델 선택
      const firstVisible = document.querySelector(`#model-dropdown-menu .dropdown-item[data-engine="${engine}"]`);
      if (firstVisible) {
        firstVisible.click();
      }
    }

    // Replicate 토큰 로드 콜백
    function onReplicateTokenLoaded(maskedToken) {
      console.log('Replicate token loaded:', maskedToken ? 'exists' : 'none');
    }

    // 엔진 로드 콜백
    function onEngineLoaded(engine) {
      state.engine = engine;
      document.querySelectorAll('#engine-group .seg-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.engine === engine);
      });
      updateModelDropdownForEngine(engine);
    }

    // Size buttons
    document.querySelectorAll('#size-group .seg-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#size-group .seg-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        state.imageSize = btn.dataset.size;
      });
    });

    // Mirror button
    const btnMirror = document.getElementById('btn-mirror');
    btnMirror.addEventListener('click', () => {
      mirrorActive = !mirrorActive;
      btnMirror.classList.toggle('active', mirrorActive);
      btnMirror.textContent = mirrorActive ? 'Mirror ON' : 'Mirror';
      if (mirrorActive) {
        sketchup.startMirror();
      } else {
        sketchup.stopMirror();
      }
    });

    // Mirror update callback (Ruby에서 호출) - 최적화
    let mirrorImageReady = true;
    function onMirrorUpdate(base64) {
      if (!mirrorActive || !mirrorImageReady) return;

      mirrorImageReady = false;

      // 직접 src 교체 (새 Image 객체 없이)
      el.originalImage.src = 'data:image/jpeg;base64,' + base64;
      el.originalImage.style.display = 'block';
      el.originalEmpty.style.display = 'none';

      // 다음 프레임 즉시 허용
      mirrorImageReady = true;
    }

    // 미러링 상태 설정 (Ruby에서 호출)
    function setMirrorActive(active) {
      mirrorActive = active;
      btnMirror.classList.toggle('active', active);
      btnMirror.textContent = active ? 'Mirror ON' : 'Mirror';
    }

    // 2점 투시 버튼
    document.getElementById('btn-2point').addEventListener('click', () => sketchup.apply2Point());

    // Camera movement buttons
    document.getElementById('cam-forward').addEventListener('click', () => sketchup.camMove('forward'));
    document.getElementById('cam-back').addEventListener('click', () => sketchup.camMove('back'));
    document.getElementById('cam-left').addEventListener('click', () => sketchup.camMove('left'));
    document.getElementById('cam-right').addEventListener('click', () => sketchup.camMove('right'));
    document.getElementById('cam-up').addEventListener('click', () => sketchup.camMove('up'));
    document.getElementById('cam-down').addEventListener('click', () => sketchup.camMove('down'));
    document.getElementById('cam-rot-left').addEventListener('click', () => sketchup.camRotate('left'));
    document.getElementById('cam-rot-right').addEventListener('click', () => sketchup.camRotate('right'));

    // Camera height presets
    document.querySelectorAll('#height-group .seg-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#height-group .seg-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        sketchup.camHeight(btn.dataset.height);
      });
    });

    // Camera FOV presets
    document.querySelectorAll('#fov-group .seg-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#fov-group .seg-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        sketchup.camFov(btn.dataset.fov);
      });
    });

    // WASD 키보드 컨트롤
    const keyMap = {
      'w': { action: 'move', dir: 'forward', btn: 'cam-forward' },
      'W': { action: 'move', dir: 'forward', btn: 'cam-forward' },
      's': { action: 'move', dir: 'back', btn: 'cam-back' },
      'S': { action: 'move', dir: 'back', btn: 'cam-back' },
      'a': { action: 'move', dir: 'left', btn: 'cam-left' },
      'A': { action: 'move', dir: 'left', btn: 'cam-left' },
      'd': { action: 'move', dir: 'right', btn: 'cam-right' },
      'D': { action: 'move', dir: 'right', btn: 'cam-right' },
      'q': { action: 'move', dir: 'up', btn: 'cam-up' },
      'Q': { action: 'move', dir: 'up', btn: 'cam-up' },
      'e': { action: 'move', dir: 'down', btn: 'cam-down' },
      'E': { action: 'move', dir: 'down', btn: 'cam-down' },
      'z': { action: 'rotate', dir: 'left', btn: 'cam-rot-left' },
      'Z': { action: 'rotate', dir: 'left', btn: 'cam-rot-left' },
      'x': { action: 'rotate', dir: 'right', btn: 'cam-rot-right' },
      'X': { action: 'rotate', dir: 'right', btn: 'cam-rot-right' }
    };

    const activeKeys = new Set();
    const keyIntervals = {};

    document.addEventListener('keydown', (e) => {
      console.log('[키보드] keydown:', e.key, 'target:', e.target.tagName);

      // 텍스트 입력 필드에서만 무시 (슬라이더는 허용)
      if (e.target.tagName === 'TEXTAREA') return;
      if (e.target.tagName === 'INPUT' && e.target.type !== 'range') return;

      const mapping = keyMap[e.key];
      console.log('[키보드] mapping:', mapping);
      if (mapping) {
        const key = e.key.toLowerCase();

        // 버튼 활성화 표시
        const btn = document.getElementById(mapping.btn);
        if (btn) btn.classList.add('active-key');

        // 처음 누를 때만 interval 시작
        if (!activeKeys.has(key)) {
          activeKeys.add(key);
          console.log('[키보드] 실행:', mapping.action, mapping.dir);

          // 즉시 실행
          if (mapping.action === 'move') {
            sketchup.camMove(mapping.dir);
          } else if (mapping.action === 'rotate') {
            sketchup.camRotate(mapping.dir);
          }

          // 반복 실행 (100ms 간격)
          keyIntervals[key] = setInterval(() => {
            if (mapping.action === 'move') {
              sketchup.camMove(mapping.dir);
            } else if (mapping.action === 'rotate') {
              sketchup.camRotate(mapping.dir);
            }
          }, 100);
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      const mapping = keyMap[e.key];
      if (mapping) {
        const key = e.key.toLowerCase();
        activeKeys.delete(key);

        // interval 정리
        if (keyIntervals[key]) {
          clearInterval(keyIntervals[key]);
          delete keyIntervals[key];
        }

        // 버튼 활성화 해제
        const btn = document.getElementById(mapping.btn);
        if (btn) btn.classList.remove('active-key');
      }
    });

    // 씬 탭 업데이트 (Ruby에서 호출)
    function onScenesUpdate(scenesJson) {
      const scenes = JSON.parse(scenesJson);
      const tabsContainer = document.getElementById('scene-tabs');

      // 탭 초기화
      tabsContainer.innerHTML = '';

      // 씬 탭 추가
      scenes.forEach((scene, index) => {
        const tab = document.createElement('div');
        tab.className = 'scene-tab';
        if (index === 0) {
          tab.classList.add('active'); // 첫 번째 씬 활성화
          // 첫 씬을 현재 씬으로 설정 (초기화 시)
          if (!state.currentScene) {
            state.currentScene = scene.name;
          }
        }
        tab.dataset.scene = scene.name;

        // 렌더링 중인 씬이면 스피너 추가
        if (renderingScenes.has(scene.name)) {
          tab.classList.add('rendering');
          const spinner = document.createElement('div');
          spinner.className = 'scene-tab-spinner';
          tab.appendChild(spinner);
        }

        // 씬 이름 텍스트
        const nameSpan = document.createElement('span');
        nameSpan.textContent = scene.name;
        tab.appendChild(nameSpan);

        tab.addEventListener('click', () => {
          // 이미 활성 탭이면 무시
          if (tab.classList.contains('active')) return;

          // 현재 씬 상태 저장 & 새 씬 상태 복원
          window.onSceneChanged(scene.name);

          // 활성 탭 변경
          document.querySelectorAll('.scene-tab').forEach(t => t.classList.remove('active'));
          tab.classList.add('active');

          // Ruby에 씬 전환 요청
          sketchup.selectScene(scene.name);
        });
        tabsContainer.appendChild(tab);
      });

      // + 버튼 다시 추가
      const addBtn = document.createElement('button');
      addBtn.className = 'scene-add-btn';
      addBtn.id = 'btn-add-scene';
      addBtn.title = '현재 뷰를 씬으로 저장';
      addBtn.textContent = '+';
      addBtn.addEventListener('click', () => sketchup.addScene());
      tabsContainer.appendChild(addBtn);
    }

    // ========================================
    // 그리드 가이드 시스템
    // ========================================

    // 그리드 그리기 함수
    function drawGrid(canvas, gridSize) {
      const ctx = canvas.getContext('2d');
      const w = canvas.width;
      const h = canvas.height;

      ctx.clearRect(0, 0, w, h);

      // 중앙 좌표
      const centerX = w / 2;
      const centerY = h / 2;

      // 일반 그리드 라인 (연한 색)
      ctx.strokeStyle = 'rgba(255, 100, 100, 0.25)';
      ctx.lineWidth = 1;

      // 수직선 (중앙에서 양쪽으로)
      for (let x = centerX % gridSize; x < w; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
        ctx.stroke();
      }

      // 수평선 (중앙에서 양쪽으로)
      for (let y = centerY % gridSize; y < h; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
      }

      // 중앙 십자 라인 (진한 색)
      ctx.strokeStyle = 'rgba(255, 100, 100, 0.8)';
      ctx.lineWidth = 2;

      // 중앙 수평선
      ctx.beginPath();
      ctx.moveTo(0, centerY);
      ctx.lineTo(w, centerY);
      ctx.stroke();

      // 중앙 수직선
      ctx.beginPath();
      ctx.moveTo(centerX, 0);
      ctx.lineTo(centerX, h);
      ctx.stroke();

      // 중앙 십자 표시
      ctx.fillStyle = 'rgba(255, 100, 100, 0.9)';
      ctx.font = 'bold 20px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('+', centerX, centerY);
    }

    // 그리드 캔버스 업데이트 (이미지 크기에 맞춤)
    function updateGridCanvas(canvas, img, slider, valueEl) {
      if (!img || img.style.display === 'none') return;
      canvas.width = img.offsetWidth;
      canvas.height = img.offsetHeight;
      canvas.style.display = 'block';
      const gridSize = parseInt(slider.value);
      valueEl.textContent = gridSize + 'px';
      drawGrid(canvas, gridSize);
    }

    // Source 패널
    const guideControlsSource = document.getElementById('guide-controls-source');
    const canvasSource = document.getElementById('guide-canvas-source');
    const sliderSource = document.getElementById('guide-slider-source');
    const valueSource = document.getElementById('guide-value-source');
    const lockSource = document.getElementById('guide-lock-source');
    const zoomSource = document.getElementById('guide-zoom-source');
    const zoomWrapperSource = document.getElementById('zoom-wrapper-source');
    const btnGuide = document.getElementById('btn-guide');
    let guideActiveSource = false;
    let guideLockedSource = false;

    btnGuide.addEventListener('click', () => {
      guideActiveSource = !guideActiveSource;
      btnGuide.classList.toggle('active', guideActiveSource);
      guideControlsSource.classList.toggle('hidden', !guideActiveSource);
      if (guideActiveSource) {
        updateGridCanvas(canvasSource, el.originalImage, sliderSource, valueSource);
      } else {
        canvasSource.style.display = 'none';
      }
    });

    sliderSource.addEventListener('input', () => {
      updateGridCanvas(canvasSource, el.originalImage, sliderSource, valueSource);
    });

    lockSource.addEventListener('click', () => {
      guideLockedSource = !guideLockedSource;
      lockSource.classList.toggle('locked', guideLockedSource);
      guideControlsSource.classList.toggle('locked', guideLockedSource);
    });

    // Zoom 슬라이더 (Source) - 이미지+그리드 함께 줌
    zoomSource.addEventListener('input', () => {
      const scale = parseInt(zoomSource.value) / 100;
      zoomWrapperSource.style.transform = `scale(${scale})`;
    });

    // Result 패널
    const guideControlsResult = document.getElementById('guide-controls-result');
    const canvasResult = document.getElementById('guide-canvas-result');
    const sliderResult = document.getElementById('guide-slider-result');
    const valueResult = document.getElementById('guide-value-result');
    const lockResult = document.getElementById('guide-lock-result');
    const zoomResult = document.getElementById('guide-zoom-result');
    const zoomWrapperResult = document.getElementById('zoom-wrapper-result');
    const btnGuideResult = document.getElementById('btn-guide-result');
    let guideActiveResult = false;
    let guideLockedResult = false;

    btnGuideResult.addEventListener('click', () => {
      guideActiveResult = !guideActiveResult;
      btnGuideResult.classList.toggle('active', guideActiveResult);
      guideControlsResult.classList.toggle('hidden', !guideActiveResult);
      if (guideActiveResult) {
        updateGridCanvas(canvasResult, el.renderImage, sliderResult, valueResult);
      } else {
        canvasResult.style.display = 'none';
      }
    });

    sliderResult.addEventListener('input', () => {
      updateGridCanvas(canvasResult, el.renderImage, sliderResult, valueResult);
    });

    lockResult.addEventListener('click', () => {
      guideLockedResult = !guideLockedResult;
      lockResult.classList.toggle('locked', guideLockedResult);
      guideControlsResult.classList.toggle('locked', guideLockedResult);
    });

    // Zoom 슬라이더 (Result)
    zoomResult.addEventListener('input', () => {
      const scale = parseInt(zoomResult.value) / 100;
      zoomWrapperResult.style.transform = `scale(${scale})`;
    });

    // 창 리사이즈 시 그리드 업데이트
    window.addEventListener('resize', () => {
      if (guideActiveSource) {
        updateGridCanvas(canvasSource, el.originalImage, sliderSource, valueSource);
      }
      if (guideActiveResult) {
        updateGridCanvas(canvasResult, el.renderImage, sliderResult, valueResult);
      }
    });

    // 패널 확장/축소 기능
    const sourcePanel = document.getElementById('source-panel');
    const resultPanel = document.getElementById('result-panel-1');
    const btnExpandSource = document.getElementById('btn-expand-source');
    const btnExpandResult = document.getElementById('btn-expand-result');

    // 확장 아이콘 SVG
    const expandIcon = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <polyline points="15 3 21 3 21 9"></polyline>
      <polyline points="9 21 3 21 3 15"></polyline>
      <line x1="21" y1="3" x2="14" y2="10"></line>
      <line x1="3" y1="21" x2="10" y2="14"></line>
    </svg>`;

    // 축소 아이콘 SVG (분할 아이콘)
    const collapseIcon = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <polyline points="4 14 10 14 10 20"></polyline>
      <polyline points="20 10 14 10 14 4"></polyline>
      <line x1="14" y1="10" x2="21" y2="3"></line>
      <line x1="3" y1="21" x2="10" y2="14"></line>
    </svg>`;

    let expandedPanel = null;

    function togglePanelExpand(panel, otherPanel, btn) {
      if (expandedPanel === panel) {
        // 이미 확장된 상태면 축소
        panel.classList.remove('fullscreen');
        otherPanel.classList.remove('hidden');
        btn.innerHTML = expandIcon;
        btn.title = 'Expand';
        // 다른 패널 버튼도 확장 아이콘으로 복구
        const otherBtn = otherPanel.querySelector('.panel-expand-btn');
        otherBtn.innerHTML = expandIcon;
        otherBtn.title = 'Expand';
        expandedPanel = null;
      } else {
        // 확장
        panel.classList.add('fullscreen');
        otherPanel.classList.add('hidden');
        btn.innerHTML = collapseIcon;
        btn.title = 'Split';
        expandedPanel = panel;
      }
    }

    btnExpandSource.addEventListener('click', () => {
      togglePanelExpand(sourcePanel, resultPanel, btnExpandSource);
    });

    btnExpandResult.addEventListener('click', () => {
      togglePanelExpand(resultPanel, sourcePanel, btnExpandResult);
    });

    // 아이콘 메뉴 클릭 이벤트
    document.querySelectorAll('.icon-menu-item').forEach(item => {
      item.addEventListener('click', () => {
        // 활성 상태 변경
        document.querySelectorAll('.icon-menu-item').forEach(i => i.classList.remove('active'));
        item.classList.add('active');

        // 메뉴별 동작
        const menuId = item.id;
        switch(menuId) {
          case 'menu-render':
            // Render 모드로 전환
            switchToRenderMode();
            break;
          case 'menu-camera':
            // Node Editor 모드로 전환
            switchToNodeMode();
            break;
          case 'menu-mix':
            // Mix 모드로 전환 (팝업 대신 인라인)
            switchToMixMode();
            break;
          case 'menu-history':
            // 히스토리 패널
            switchToRenderMode();
            break;
          case 'menu-help':
            // 도움말
            break;
          case 'menu-settings':
            openSettingsPanel();
            break;
        }
      });
    });

    // ========================================
    // 모드 전환 (Render <-> Mix <-> Node)
    // ========================================
    let currentMode = 'render';

    function switchToRenderMode() {
      if (currentMode === 'render') return;
      currentMode = 'render';

      // Render 모드 UI 표시
      document.getElementById('render-sidebar').style.display = 'flex';
      document.getElementById('render-main-area').style.display = 'flex';

      // Mix 모드 UI 숨김
      document.getElementById('mix-mode-panel').classList.remove('active');
      document.getElementById('mix-main-area').classList.remove('active');
      document.getElementById('mix-options-panel').classList.remove('active');

      // Node 모드 UI 숨김
      document.getElementById('node-editor-container').classList.remove('active');

      setStatus('Render Mode');
    }

    function switchToMixMode() {
      if (currentMode === 'mix') return;
      currentMode = 'mix';

      // Render 모드 UI 숨김
      document.getElementById('render-sidebar').style.display = 'none';
      document.getElementById('render-main-area').style.display = 'none';

      // Node 모드 UI 숨김
      document.getElementById('node-editor-container').classList.remove('active');

      // Mix 모드 UI 표시
      document.getElementById('mix-mode-panel').classList.add('active');
      document.getElementById('mix-main-area').classList.add('active');
      document.getElementById('mix-options-panel').classList.add('active');

      // Mix 모드 초기화 (캡처된 이미지가 있으면 로드)
      initMixMode();
      setMixStatus('Mix Mode - ' + mixState.mode);
    }

    function switchToNodeMode() {
      if (currentMode === 'node') return;
      currentMode = 'node';

      // Render 모드 UI 숨김
      document.getElementById('render-sidebar').style.display = 'none';
      document.getElementById('render-main-area').style.display = 'none';

      // Mix 모드 UI 숨김
      document.getElementById('mix-mode-panel').classList.remove('active');
      document.getElementById('mix-main-area').classList.remove('active');
      document.getElementById('mix-options-panel').classList.remove('active');

      // Node 모드 UI 표시
      document.getElementById('node-editor-container').classList.add('active');

      // 초기 노드 없으면 자동 생성
      if (nodeEditor.nodes.length === 0) {
        nodeEditor.addNode('source', 80, 120);
        nodeEditor.addNode('renderer', 480, 120);
        // 자동 연결
        const sourceNode = nodeEditor.nodes.find(n => n.type === 'source');
        const rendererNode = nodeEditor.nodes.find(n => n.type === 'renderer');
        if (sourceNode && rendererNode) {
          nodeEditor.connect(sourceNode.id, rendererNode.id);
        }
      }

      // Source 노드에 이미지 자동 로드
      const sourceNode = nodeEditor.nodes.find(n => n.type === 'source');
      if (sourceNode && !sourceNode.data.image) {
        if (state.originalImage) {
          // Render 모드에서 이미 캡처한 이미지가 있으면 바로 사용
          sourceNode.data.image = state.originalImage;
          sourceNode.thumbnail = state.originalImage;
          sourceNode.dirty = false;
          nodeEditor.renderNode(sourceNode);
        } else {
          // 없으면 자동 캡처
          nodeEditor.executeSourceNode(sourceNode);
        }
      }

      setStatus('Node Editor Mode');
    }

    // ========================================
    // 2차 생성 - 새 결과 패널 동적 생성
    // ========================================

    // 새 결과 패널 HTML 생성
    function createResultPanelHTML(id) {
      return `
        <div class="image-panel result-panel" id="result-panel-${id}" data-result-index="${id}">
          <div class="panel-label">
            <span>Result ${id}</span>
            <button class="panel-close-btn" id="btn-close-${id}" title="패널 닫기">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>
            <button class="panel-expand-btn" id="btn-expand-result-${id}" title="Expand">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="15 3 21 3 21 9"></polyline>
                <polyline points="9 21 3 21 3 15"></polyline>
                <line x1="21" y1="3" x2="14" y2="10"></line>
                <line x1="3" y1="21" x2="10" y2="14"></line>
              </svg>
            </button>
          </div>
          <div class="panel-content">
            <div class="empty-state" id="render-empty-${id}">Ready</div>
            <div class="image-zoom-container" id="zoom-container-result-${id}">
              <div class="image-zoom-wrapper" id="zoom-wrapper-result-${id}">
                <img id="render-image-${id}" style="display:none;">
              </div>
            </div>
            <div class="loading-overlay hidden" id="loading-${id}">
              <div class="loading-spinner"></div>
              <div class="loading-text" id="loading-text-${id}">Generating...</div>
              <div class="loading-subtext">Processing previous result</div>
              <div class="loading-progress"><div class="loading-progress-bar"></div></div>
            </div>
          </div>
        </div>
      `;
    }

    // 새 결과 패널 추가
    function addResultPanel(sourceImage, sourcePanelId) {
      const newId = state.nextResultId;
      state.nextResultId++;
      state.resultPanels.push({ id: newId, image: null, sourceImage: sourceImage, sourcePanelId: sourcePanelId });

      // HTML 삽입
      const container = document.getElementById('image-container');
      const html = createResultPanelHTML(newId);
      container.insertAdjacentHTML('beforeend', html);

      // 새 패널의 이벤트 바인딩
      bindResultPanelEvents(newId);

      return newId;
    }

    // 결과 패널 이벤트 바인딩
    function bindResultPanelEvents(id) {
      // 닫기 버튼
      const closeBtn = document.getElementById(`btn-close-${id}`);
      if (closeBtn) {
        closeBtn.addEventListener('click', () => removeResultPanel(id));
      }

      // 2차 생성 버튼
      const regenBtn = document.getElementById(`btn-regenerate-${id}`);
      if (regenBtn) {
        regenBtn.addEventListener('click', () => startRegenerate(id));
      }
    }

    // 결과 패널 제거
    function removeResultPanel(id) {
      // 첫 번째 결과 패널(Result 1)은 제거 불가
      if (id === 1) return;

      const panel = document.getElementById(`result-panel-${id}`);
      if (panel) {
        panel.remove();
        state.resultPanels = state.resultPanels.filter(p => p.id !== id);
      }
    }

    // 2차 생성 시작
    function startRegenerate(sourcePanelId) {
      // 소스 패널의 이미지 가져오기
      const panelData = state.resultPanels.find(p => p.id === sourcePanelId);
      if (!panelData || !panelData.image) {
        setStatus('소스 이미지가 없습니다');
        return;
      }

      // 새 결과 패널 추가
      const newPanelId = addResultPanel(panelData.image, sourcePanelId);

      // 프롬프트는 SOURCE 패널에서 가져옴
      const prompt = el.promptSource.value || '';

      // 로딩 표시
      const loadingEl = document.getElementById(`loading-${newPanelId}`);
      if (loadingEl) loadingEl.classList.remove('hidden');

      // Ruby에 2차 생성 요청 (이전 결과 이미지를 소스로)
      setStatus(`Result ${newPanelId} 생성중...`);
      sketchup.regenerate(panelData.image, prompt, newPanelId);
    }

    // 2차 생성 완료 콜백 (Ruby에서 호출)
    function onRegenerateComplete(base64, panelId) {
      const panelData = state.resultPanels.find(p => p.id === panelId);
      if (panelData) panelData.image = base64;

      // 이미지 표시
      const imgEl = document.getElementById(`render-image-${panelId}`);
      const emptyEl = document.getElementById(`render-empty-${panelId}`);
      const loadingEl = document.getElementById(`loading-${panelId}`);

      if (imgEl) {
        imgEl.src = 'data:image/png;base64,' + base64;
        imgEl.style.display = 'block';
      }
      if (emptyEl) emptyEl.style.display = 'none';
      if (loadingEl) loadingEl.classList.add('hidden');

      setStatus(`Result ${panelId} 완료`);
    }

    // 2차 생성 에러 콜백 (Ruby에서 호출)
    function onRegenerateError(msg, panelId) {
      const loadingEl = document.getElementById(`loading-${panelId}`);
      if (loadingEl) loadingEl.classList.add('hidden');

      setStatus(`Result ${panelId} 실패: ${msg}`);
    }


    // ========================================
    // Mix Mode - State & Elements
    // ========================================
    const mixState = {
      mode: 'add-remove',
      baseImage: null,
      baseImageBase64: null,
      objectImage: null,
      materialImage: null,
      floorplanImage: null,
      hotspots: [],
      selectedHotspot: null,
      brushSize: 30,
      brushColor: 'rgba(255, 59, 48, 0.5)',
      tool: 'brush',
      isDrawing: false,
      canvasScale: 1,
      sceneContext: null
    };

    const mixEl = {
      emptyState: document.getElementById('mix-empty-state'),
      canvasWrapper: document.getElementById('mix-canvas-wrapper'),
      mainCanvas: document.getElementById('mix-main-canvas'),
      maskCanvas: document.getElementById('mix-mask-canvas'),
      drawCanvas: document.getElementById('mix-draw-canvas'),
      loading: document.getElementById('mix-loading'),
      loadingText: document.getElementById('mix-loading-text'),
      loadingSubtext: document.getElementById('mix-loading-subtext'),
      statusText: document.getElementById('mix-status-text'),
      coordOverlay: document.getElementById('mix-coord-overlay'),
      coordWorld: document.getElementById('mix-coord-world'),
      coordScreen: document.getElementById('mix-coord-screen'),
      optionsTitle: document.getElementById('mix-options-title'),
      optionsSubtitle: document.getElementById('mix-options-subtitle'),
      btnApply: document.getElementById('mix-btn-apply'),
      btnBack: document.getElementById('mix-btn-back'),
      hotspotList: document.getElementById('mix-hotspot-list'),
      // Toolbars
      toolbarAddRemove: document.getElementById('mix-toolbar-add-remove'),
      toolbarMask: document.getElementById('mix-toolbar-mask'),
      toolbarFloorplan: document.getElementById('mix-toolbar-floorplan'),
      // Options panels
      optionsAddRemove: document.getElementById('mix-options-add-remove'),
      optionsInpaint: document.getElementById('mix-options-inpaint'),
      optionsMaterial: document.getElementById('mix-options-material'),
      optionsFloorplan: document.getElementById('mix-options-floorplan'),
      // Inputs
      brushSize: document.getElementById('mix-brush-size'),
      brushSizeValue: document.getElementById('mix-brush-size-value'),
      materialBrushSize: document.getElementById('mix-material-brush-size'),
      materialBrushSizeValue: document.getElementById('mix-material-brush-size-value')
    };

    function setMixStatus(text) {
      if (mixEl.statusText) mixEl.statusText.textContent = text;
    }

    // ========================================
    // Mix Mode - Initialization
    // ========================================
    function initMixMode() {
      // 선택된 패널의 이미지를 Mix 캔버스에 로드
      const selectedImage = getSelectedImage();
      if (selectedImage) {
        mixState.baseImageBase64 = selectedImage;
        loadMixBaseImage(selectedImage);
      }
      // 스케치업에 씬 컨텍스트 요청
      callRuby('mix_get_scene_context');
    }

    function loadMixBaseImage(base64) {
      const img = new Image();
      img.onload = () => {
        mixState.baseImage = img;

        const container = document.querySelector('.mix-canvas-container');
        const maxW = container.clientWidth - 40;
        const maxH = container.clientHeight - 40;

        let w = img.width;
        let h = img.height;

        if (w > maxW) {
          const ratio = maxW / w;
          w = maxW;
          h = h * ratio;
        }
        if (h > maxH) {
          const ratio = maxH / h;
          h = maxH;
          w = w * ratio;
        }

        mixState.canvasScale = w / img.width;

        mixEl.mainCanvas.width = w;
        mixEl.mainCanvas.height = h;
        mixEl.maskCanvas.width = w;
        mixEl.maskCanvas.height = h;
        mixEl.drawCanvas.width = w;
        mixEl.drawCanvas.height = h;

        const ctx = mixEl.mainCanvas.getContext('2d');
        ctx.drawImage(img, 0, 0, w, h);

        mixEl.emptyState.classList.add('hidden');
        mixEl.canvasWrapper.classList.remove('hidden');

        setMixStatus('Image loaded');
        updateMixApplyButton();
      };
      img.src = 'data:image/png;base64,' + base64;
    }

    // ========================================
    // Mix Mode - Mode Switching
    // ========================================
    document.querySelectorAll('.mix-mode-item').forEach(item => {
      item.addEventListener('click', () => {
        document.querySelectorAll('.mix-mode-item').forEach(i => i.classList.remove('active'));
        item.classList.add('active');
        switchMixSubMode(item.dataset.mixmode);
      });
    });

    function switchMixSubMode(mode) {
      mixState.mode = mode;

      // Hide all
      mixEl.toolbarAddRemove.classList.add('hidden');
      mixEl.toolbarMask.classList.add('hidden');
      mixEl.toolbarFloorplan.classList.add('hidden');
      mixEl.optionsAddRemove.classList.add('hidden');
      mixEl.optionsInpaint.classList.add('hidden');
      mixEl.optionsMaterial.classList.add('hidden');
      mixEl.optionsFloorplan.classList.add('hidden');

      // Show relevant
      switch(mode) {
        case 'add-remove':
          mixEl.toolbarAddRemove.classList.remove('hidden');
          mixEl.optionsAddRemove.classList.remove('hidden');
          mixEl.optionsTitle.textContent = 'Object Insert & Remove';
          mixEl.optionsSubtitle.textContent = '3D 좌표 기반 오브젝트 배치';
          mixEl.drawCanvas.style.cursor = 'crosshair';
          break;
        case 'inpaint':
          mixEl.toolbarMask.classList.remove('hidden');
          mixEl.optionsInpaint.classList.remove('hidden');
          mixEl.optionsTitle.textContent = 'Inpainting';
          mixEl.optionsSubtitle.textContent = '마스킹 영역만 수정';
          mixEl.drawCanvas.style.cursor = 'crosshair';
          break;
        case 'material':
          mixEl.toolbarMask.classList.remove('hidden');
          mixEl.optionsMaterial.classList.remove('hidden');
          mixEl.optionsTitle.textContent = 'Material Replace';
          mixEl.optionsSubtitle.textContent = '재질 투영 및 교체';
          mixEl.drawCanvas.style.cursor = 'crosshair';
          break;
        case 'floorplan':
          mixEl.toolbarFloorplan.classList.remove('hidden');
          mixEl.optionsFloorplan.classList.remove('hidden');
          mixEl.optionsTitle.textContent = 'Floorplan to Isometric';
          mixEl.optionsSubtitle.textContent = '2D → 3D 변환';
          mixEl.drawCanvas.style.cursor = 'default';
          break;
      }

      // Clear mask
      const ctx = mixEl.maskCanvas.getContext('2d');
      ctx.clearRect(0, 0, mixEl.maskCanvas.width, mixEl.maskCanvas.height);

      updateMixApplyButton();
      setMixStatus('Mode: ' + mode);
    }

    // ========================================
    // Mix Mode - Apply Button Logic
    // ========================================
    function updateMixApplyButton() {
      let canApply = false;

      switch(mixState.mode) {
        case 'add-remove':
          canApply = mixState.baseImage && mixState.hotspots.length > 0;
          break;
        case 'inpaint':
          canApply = mixState.baseImage && hasMixMaskContent() &&
                     document.getElementById('mix-inpaint-instruction').value.trim();
          break;
        case 'material':
          canApply = mixState.baseImage && hasMixMaskContent() && mixState.materialImage;
          break;
        case 'floorplan':
          canApply = mixState.floorplanImage;
          break;
      }

      mixEl.btnApply.disabled = !canApply;
    }

    function hasMixMaskContent() {
      const ctx = mixEl.maskCanvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, mixEl.maskCanvas.width, mixEl.maskCanvas.height);
      return imageData.data.some((v, i) => i % 4 === 3 && v > 0);
    }

    // ========================================
    // Mix Mode - Drawing (Mask)
    // ========================================
    let mixLastX, mixLastY;

    mixEl.drawCanvas.addEventListener('mousedown', (e) => {
      if (mixState.mode !== 'inpaint' && mixState.mode !== 'material') return;

      mixState.isDrawing = true;
      const rect = mixEl.drawCanvas.getBoundingClientRect();
      mixLastX = e.clientX - rect.left;
      mixLastY = e.clientY - rect.top;
    });

    mixEl.drawCanvas.addEventListener('mousemove', (e) => {
      const rect = mixEl.drawCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // Show coordinates
      if (mixState.mode === 'add-remove') {
        mixEl.coordOverlay.classList.add('visible');
        mixEl.coordScreen.textContent = `X: ${Math.round(x / mixState.canvasScale)} Y: ${Math.round(y / mixState.canvasScale)}`;
      }

      if (!mixState.isDrawing) return;
      if (mixState.mode !== 'inpaint' && mixState.mode !== 'material') return;

      const ctx = mixEl.maskCanvas.getContext('2d');
      const brushSize = mixState.mode === 'material' ?
        parseInt(mixEl.materialBrushSize.value) : parseInt(mixEl.brushSize.value);

      ctx.beginPath();
      ctx.lineWidth = brushSize;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      if (mixState.tool === 'eraser') {
        ctx.globalCompositeOperation = 'destination-out';
        ctx.strokeStyle = 'rgba(0,0,0,1)';
      } else {
        ctx.globalCompositeOperation = 'source-over';
        ctx.strokeStyle = mixState.brushColor;
      }

      ctx.moveTo(mixLastX, mixLastY);
      ctx.lineTo(x, y);
      ctx.stroke();

      mixLastX = x;
      mixLastY = y;
    });

    mixEl.drawCanvas.addEventListener('mouseup', () => {
      mixState.isDrawing = false;
      updateMixApplyButton();
    });

    mixEl.drawCanvas.addEventListener('mouseleave', () => {
      mixState.isDrawing = false;
      mixEl.coordOverlay.classList.remove('visible');
    });

    // ========================================
    // Mix Mode - Tool Buttons
    // ========================================
    document.getElementById('mix-tool-brush').addEventListener('click', () => {
      mixState.tool = 'brush';
      document.getElementById('mix-tool-brush').classList.add('active');
      document.getElementById('mix-tool-eraser').classList.remove('active');
    });

    document.getElementById('mix-tool-eraser').addEventListener('click', () => {
      mixState.tool = 'eraser';
      document.getElementById('mix-tool-eraser').classList.add('active');
      document.getElementById('mix-tool-brush').classList.remove('active');
    });

    document.getElementById('mix-tool-clear-mask').addEventListener('click', () => {
      const ctx = mixEl.maskCanvas.getContext('2d');
      ctx.clearRect(0, 0, mixEl.maskCanvas.width, mixEl.maskCanvas.height);
      updateMixApplyButton();
    });

    // Brush size sliders
    mixEl.brushSize.addEventListener('input', () => {
      mixEl.brushSizeValue.textContent = mixEl.brushSize.value + 'px';
    });

    mixEl.materialBrushSize.addEventListener('input', () => {
      mixEl.materialBrushSizeValue.textContent = mixEl.materialBrushSize.value + 'px';
    });

    // Color buttons
    document.querySelectorAll('.mix-color-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.mix-color-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        mixState.brushColor = btn.dataset.color;
      });
    });

    // ========================================
    // Mix Mode - File Uploads
    // ========================================
    document.getElementById('mix-upload-object').addEventListener('click', () => {
      document.getElementById('mix-object-file').click();
    });

    document.getElementById('mix-object-file').addEventListener('change', (e) => {
      handleMixFileUpload(e.target.files[0], 'object');
    });

    document.getElementById('mix-upload-material').addEventListener('click', () => {
      document.getElementById('mix-material-file').click();
    });

    document.getElementById('mix-material-file').addEventListener('change', (e) => {
      handleMixFileUpload(e.target.files[0], 'material');
    });

    document.getElementById('mix-upload-floorplan').addEventListener('click', () => {
      document.getElementById('mix-floorplan-file').click();
    });

    document.getElementById('mix-floorplan-file').addEventListener('change', (e) => {
      handleMixFileUpload(e.target.files[0], 'floorplan');
    });

    function handleMixFileUpload(file, type) {
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const base64 = e.target.result.split(',')[1];

        switch(type) {
          case 'object':
            mixState.objectImage = base64;
            document.getElementById('mix-object-preview').src = e.target.result;
            document.getElementById('mix-object-preview').classList.remove('hidden');
            document.getElementById('mix-upload-object').classList.add('has-image');
            break;
          case 'material':
            mixState.materialImage = base64;
            document.getElementById('mix-material-preview').src = e.target.result;
            document.getElementById('mix-material-preview').classList.remove('hidden');
            document.getElementById('mix-upload-material').classList.add('has-image');
            break;
          case 'floorplan':
            mixState.floorplanImage = base64;
            document.getElementById('mix-floorplan-preview').src = e.target.result;
            document.getElementById('mix-floorplan-preview').classList.remove('hidden');
            document.getElementById('mix-upload-floorplan').classList.add('has-image');
            break;
        }

        updateMixApplyButton();
      };
      reader.readAsDataURL(file);
    }

    // ========================================
    // Mix Mode - Hotspot System
    // ========================================
    mixEl.drawCanvas.addEventListener('click', (e) => {
      if (mixState.mode !== 'add-remove') return;

      const rect = mixEl.drawCanvas.getBoundingClientRect();
      const screenX = Math.round((e.clientX - rect.left) / mixState.canvasScale);
      const screenY = Math.round((e.clientY - rect.top) / mixState.canvasScale);

      // 스케치업에 3D 좌표 요청
      callRuby('mix_get_3d_coord', screenX, screenY);
    });

    function onMixHotspotFromSketchUp(dataJson) {
      const data = JSON.parse(dataJson);

      const id = 'hotspot-' + Date.now();
      const objectName = document.getElementById('mix-object-name');
      const objectWidth = document.getElementById('mix-object-width');
      const objectHeight = document.getElementById('mix-object-height');
      const objectDepth = document.getElementById('mix-object-depth');

      const hotspot = {
        id,
        position: data.position,
        normal: data.normal,
        screenPos: data.screen_pos,
        floorReference: data.floor_reference,
        name: objectName.value || 'Object ' + (mixState.hotspots.length + 1),
        image: mixState.objectImage,
        estimatedSize: {
          width: parseInt(objectWidth.value) || 500,
          height: parseInt(objectHeight.value) || 800,
          depth: parseInt(objectDepth.value) || 500
        },
        scale: 1.0,
        rotation: 0
      };

      mixState.hotspots.push(hotspot);
      renderMixHotspots();
      updateMixHotspotList();
      updateMixApplyButton();

      setMixStatus(`Hotspot added at (${Math.round(data.position.x)}, ${Math.round(data.position.y)}, ${Math.round(data.position.z)}) mm`);
    }

    function renderMixHotspots() {
      // Remove existing markers
      document.querySelectorAll('.mix-hotspot-marker').forEach(m => m.remove());

      mixState.hotspots.forEach((h, i) => {
        const marker = document.createElement('div');
        marker.className = 'mix-hotspot-marker';
        marker.textContent = i + 1;

        const screenX = h.screenPos.x * mixState.canvasScale;
        const screenY = h.screenPos.y * mixState.canvasScale;
        marker.style.left = screenX + 'px';
        marker.style.top = screenY + 'px';
        marker.dataset.id = h.id;

        if (mixState.selectedHotspot === h.id) {
          marker.classList.add('selected');
        }

        marker.addEventListener('click', (e) => {
          e.stopPropagation();
          mixState.selectedHotspot = h.id;
          renderMixHotspots();
          updateMixHotspotList();
        });

        mixEl.canvasWrapper.appendChild(marker);
      });
    }

    function updateMixHotspotList() {
      if (mixState.hotspots.length === 0) {
        mixEl.hotspotList.innerHTML = `
          <div class="mix-empty-state" style="font-size:11px;padding:16px;color:#555;">
            스케치업 뷰포트에서 클릭하여 핫스팟을 추가하세요
          </div>`;
        return;
      }

      mixEl.hotspotList.innerHTML = mixState.hotspots.map((h, i) => `
        <div class="mix-hotspot-item ${mixState.selectedHotspot === h.id ? 'selected' : ''}" data-id="${h.id}">
          <div class="mix-hotspot-item-header">
            <div class="mix-hotspot-item-num">${i + 1}</div>
            <div class="mix-hotspot-item-info">
              <div class="mix-hotspot-item-name">${h.name}</div>
              <div class="mix-hotspot-item-coords">
                X: ${Math.round(h.position.x)} Y: ${Math.round(h.position.y)} Z: ${Math.round(h.position.z)} mm
              </div>
            </div>
            <button class="mix-hotspot-item-delete" data-id="${h.id}">
              <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>
          </div>
        </div>
      `).join('');

      // Event handlers
      mixEl.hotspotList.querySelectorAll('.mix-hotspot-item').forEach(item => {
        item.addEventListener('click', () => {
          mixState.selectedHotspot = item.dataset.id;
          renderMixHotspots();
          updateMixHotspotList();
        });
      });

      mixEl.hotspotList.querySelectorAll('.mix-hotspot-item-delete').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const id = btn.dataset.id;
          mixState.hotspots = mixState.hotspots.filter(h => h.id !== id);
          if (mixState.selectedHotspot === id) mixState.selectedHotspot = null;
          renderMixHotspots();
          updateMixHotspotList();
          updateMixApplyButton();
        });
      });
    }

    // ========================================
    // Mix Mode - Apply & Callbacks
    // ========================================
    mixEl.btnApply.addEventListener('click', applyMix);
    mixEl.btnBack.addEventListener('click', () => {
      // 메뉴 아이콘 상태 업데이트
      document.querySelectorAll('.icon-menu-item').forEach(i => i.classList.remove('active'));
      document.getElementById('menu-render').classList.add('active');
      switchToRenderMode();
    });

    function applyMix() {
      showMixLoading('Processing...', 'AI가 씬을 분석하고 있습니다');

      const data = {
        mode: mixState.mode,
        sceneContext: mixState.sceneContext
      };

      switch(mixState.mode) {
        case 'add-remove':
          data.baseImage = mixState.baseImageBase64;
          data.hotspots = mixState.hotspots.map(h => ({
            position: h.position,
            normal: h.normal,
            screenPos: h.screenPos,
            floorReference: h.floorReference,
            name: h.name,
            image: h.image,
            estimatedSize: h.estimatedSize,
            scale: h.scale,
            rotation: h.rotation
          }));
          data.instruction = document.getElementById('mix-object-instruction').value;
          break;

        case 'inpaint':
          data.baseImage = mixState.baseImageBase64;
          data.maskImage = mixCanvasToBase64(mixEl.maskCanvas);
          data.instruction = document.getElementById('mix-inpaint-instruction').value;
          data.preserve = {
            lighting: document.getElementById('mix-preserve-lighting').checked,
            style: document.getElementById('mix-preserve-style').checked
          };
          break;

        case 'material':
          data.baseImage = mixState.baseImageBase64;
          data.maskImage = mixCanvasToBase64(mixEl.maskCanvas);
          data.materialImage = mixState.materialImage;
          data.description = document.getElementById('mix-material-description').value;
          break;

        case 'floorplan':
          data.floorplanImage = mixState.floorplanImage;
          data.parameters = {
            wallHeight: parseInt(document.getElementById('mix-wall-height').value),
            wallThickness: parseInt(document.getElementById('mix-wall-thickness').value),
            style: document.getElementById('mix-floorplan-style').value
          };
          data.instruction = document.getElementById('mix-floorplan-instruction').value;
          break;
      }

      callRuby('mix_apply', JSON.stringify(data));
    }

    function mixCanvasToBase64(canvas) {
      return canvas.toDataURL('image/png').split(',')[1];
    }

    function showMixLoading(text, subtext) {
      mixEl.loadingText.textContent = text || 'Processing...';
      mixEl.loadingSubtext.textContent = subtext || '';
      mixEl.loading.classList.remove('hidden');
    }

    function hideMixLoading() {
      mixEl.loading.classList.add('hidden');
    }

    // Ruby Callbacks for Mix Mode
    function onMixSceneContextLoaded(contextJson) {
      mixState.sceneContext = JSON.parse(contextJson);
      document.getElementById('mix-scene-info').textContent =
        `Camera: FOV ${mixState.sceneContext.camera.fov.toFixed(0)}°`;
    }

    function onMixCoordReceived(coordJson) {
      const data = JSON.parse(coordJson);
      mixEl.coordWorld.textContent = `X: ${Math.round(data.position.x)} Y: ${Math.round(data.position.y)} Z: ${Math.round(data.position.z)}`;
      onMixHotspotFromSketchUp(coordJson);
    }

    function onMixComplete(resultBase64) {
      hideMixLoading();

      const img = new Image();
      img.onload = () => {
        const ctx = mixEl.mainCanvas.getContext('2d');
        ctx.drawImage(img, 0, 0, mixEl.mainCanvas.width, mixEl.mainCanvas.height);

        // Clear
        const maskCtx = mixEl.maskCanvas.getContext('2d');
        maskCtx.clearRect(0, 0, mixEl.maskCanvas.width, mixEl.maskCanvas.height);
        mixState.hotspots = [];
        mixState.selectedHotspot = null;
        renderMixHotspots();
        updateMixHotspotList();

        setMixStatus('Mix complete!');
      };
      img.src = 'data:image/png;base64,' + resultBase64;
    }

    function onMixError(message) {
      hideMixLoading();
      setMixStatus('Error: ' + message);
      alert('Mix Error: ' + message);
    }

    // Input listeners for Apply button
    document.getElementById('mix-inpaint-instruction').addEventListener('input', updateMixApplyButton);
    document.getElementById('mix-material-description').addEventListener('input', updateMixApplyButton);

    // 커스텀 드롭다운 - 모델 선택
    let currentModelValue = 'gemini-2.0-flash-exp';
    const modelDropdown = document.getElementById('model-dropdown');
    const modelDropdownSelected = document.getElementById('model-dropdown-selected');
    const modelDropdownMenu = document.getElementById('model-dropdown-menu');
    const modelSelectedText = document.getElementById('model-selected-text');

    // 드롭다운 토글
    modelDropdownSelected.addEventListener('click', function(e) {
      e.stopPropagation();
      modelDropdown.classList.toggle('open');
    });

    // 아이템 선택
    modelDropdownMenu.querySelectorAll('.dropdown-item').forEach(function(item) {
      item.addEventListener('click', function(e) {
        e.stopPropagation();
        const value = this.dataset.value;
        const text = this.childNodes[0].textContent.trim();

        // 이전 선택 해제
        modelDropdownMenu.querySelectorAll('.dropdown-item').forEach(function(i) {
          i.classList.remove('selected');
        });

        // 새 선택
        this.classList.add('selected');
        modelSelectedText.textContent = text;
        currentModelValue = value;

        // 드롭다운 닫기
        modelDropdown.classList.remove('open');

        // Ruby에 저장
        sketchup.saveModel(value);
      });
    });

    // 외부 클릭시 드롭다운 닫기
    document.addEventListener('click', function(e) {
      if (!modelDropdown.contains(e.target)) {
        modelDropdown.classList.remove('open');
      }
    });

    // 현재 모델 값 가져오기 함수
    function getSelectedModel() {
      return currentModelValue;
    }

    // Ruby에서 호출되는 콜백 - 모델 로드
    function onModelLoaded(model) {
      if (model) {
        currentModelValue = model;
        // data-value로 직접 찾기 (특수문자 대응)
        const items = modelDropdownMenu.querySelectorAll('.dropdown-item');
        let found = null;
        items.forEach(function(item) {
          if (item.dataset.value === model) {
            found = item;
          }
        });
        if (found) {
          items.forEach(function(i) {
            i.classList.remove('selected');
          });
          found.classList.add('selected');
          modelSelectedText.textContent = found.childNodes[0].textContent.trim();
        }
      }
    }

    // 즉시 초기화 (지연 없이)
    sketchup.checkApiStatus();
    sketchup.getScenes();
    sketchup.loadModel();
    sketchup.loadHistory();  // 히스토리 로드

    // 로딩 화면 숨기기
    setTimeout(function() {
      const loader = document.getElementById('app-loader');
      if (loader) {
        loader.classList.add('hidden');
        setTimeout(function() {
          loader.style.display = 'none';
        }, 500);
      }
    }, 800);

    // ========================================
    // Node Editor System
    // ========================================
    const nodeEditor = {
      nodes: [],
      connections: [],
      nextNodeId: 1,
      selectedNode: null,
      draggingNode: null,
      dragOffset: { x: 0, y: 0 },
      connecting: null, // 연결 중인 노드 ID
      dirty: false,

      // 노드 추가
      addNode: function(type, x, y) {
        const node = {
          id: this.nextNodeId++,
          type: type,
          x: x,
          y: y,
          dirty: true,
          data: this.getDefaultData(type),
          thumbnail: null
        };
        this.nodes.push(node);
        this.renderNode(node);
        this.selectNode(node.id);
        this.markDirty();
        return node;
      },

      // 같은 타입의 노드 중 가장 아래에 있는 노드를 찾아서 그 아래에 배치
      addNodeBelow: function(clickedNode, newType) {
        // 같은 타입의 기존 노드들 중 가장 아래(y가 큰) 노드 찾기
        const sameTypeNodes = this.nodes.filter(n => n.type === newType);
        let targetX, targetY;

        if (sameTypeNodes.length > 0) {
          // 같은 타입 중 가장 아래 노드 찾기
          const bottomNode = sameTypeNodes.reduce((a, b) => a.y > b.y ? a : b);
          targetX = bottomNode.x;
          targetY = bottomNode.y + 260; // 카드 높이 + 간격
        } else {
          // 같은 타입이 없으면 클릭한 노드 기준 배치
          if (newType === 'source') {
            // 소스 카드가 없으면 클릭한 카드 왼쪽에 아래로
            const sourceNodes = this.nodes.filter(n => n.type === 'source');
            targetX = sourceNodes.length > 0 ? sourceNodes[0].x : 80;
            targetY = clickedNode.y + 260;
          } else if (newType === 'renderer') {
            const rendererNodes = this.nodes.filter(n => n.type === 'renderer');
            targetX = rendererNodes.length > 0 ? rendererNodes[0].x : 480;
            targetY = clickedNode.y + 260;
          } else {
            // animation - renderer 아래에 배치
            const rendererNodes = this.nodes.filter(n => n.type === 'renderer');
            if (rendererNodes.length > 0) {
              const bottomRenderer = rendererNodes.reduce((a, b) => a.y > b.y ? a : b);
              targetX = bottomRenderer.x;
              targetY = bottomRenderer.y + 260;
            } else {
              targetX = 480;
              targetY = clickedNode.y + 260;
            }
          }
        }

        const newNode = this.addNode(newType, targetX, targetY);

        // 자동 연결: 소스→렌더러, 렌더러→애니메이션
        if (newType === 'renderer') {
          const sourceNodes = this.nodes.filter(n => n.type === 'source');
          if (sourceNodes.length > 0) {
            this.connect(sourceNodes[sourceNodes.length - 1].id, newNode.id);
          }
        } else if (newType === 'animation') {
          const rendererNodes = this.nodes.filter(n => n.type === 'renderer');
          if (rendererNodes.length > 0) {
            this.connect(rendererNodes[rendererNodes.length - 1].id, newNode.id);
          }
        }
      },

      // 기본 데이터
      getDefaultData: function(type) {
        if (type === 'source') {
          return {
            time: 'day',
            light: 'on',
            image: null
          };
        } else if (type === 'renderer') {
          return {
            mode: 'nanobanana-pro',
            resolution: '2048',
            aspect: 'original',
            presets: [],
            customPrompt: ''
          };
        } else if (type === 'animation') {
          return {
            fps: 24,
            duration: 3,
            style: 'smooth',
            prompt: ''
          };
        }
        return {};
      },

      // 노드 렌더링 (positionOnly=true면 위치만 업데이트, innerHTML 재생성 안함)
      renderNode: function(node, positionOnly) {
        const canvas = document.getElementById('node-canvas');
        let el = document.getElementById('node-' + node.id);
        const isNew = !el;

        if (isNew) {
          el = document.createElement('div');
          el.id = 'node-' + node.id;
          el.className = 'node node-' + node.type;
          if (node.dirty) el.classList.add('dirty');
          el.style.willChange = 'transform';
          canvas.appendChild(el);

          // 드래그 이벤트
          el.addEventListener('mousedown', (e) => this.onNodeMouseDown(e, node));
          el.addEventListener('click', (e) => {
            e.stopPropagation();
            this.selectNode(node.id);
          });
        }

        // transform으로 위치 지정 (left/top 대신 GPU 가속)
        el.style.transform = `translate(${node.x}px, ${node.y}px)`;
        el.classList.toggle('dirty', node.dirty);
        el.classList.toggle('selected', this.selectedNode === node.id);

        // 드래그 중이면 위치만 업데이트하고 끝
        if (positionOnly) return;

        // 내용 변경 필요 여부 체크 (캐시된 상태와 비교)
        const currentState = (node.thumbnail || '') + '|' + node.type + '|' + node.dirty;
        if (!isNew && el._cachedState === currentState) return;
        el._cachedState = currentState;

        const icons = {
          source: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>',
          renderer: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M18.435,3.06H5.565a2.5,2.5,0,0,0-2.5,2.5V18.44a2.507,2.507,0,0,0,2.5,2.5h12.87a2.507,2.507,0,0,0,2.5-2.5V5.56A2.5,2.5,0,0,0,18.435,3.06ZM4.065,5.56a1.5,1.5,0,0,1,1.5-1.5h12.87a1.5,1.5,0,0,1,1.5,1.5v8.66l-3.88-3.88a1.509,1.509,0,0,0-2.12,0l-4.56,4.57a.513.513,0,0,1-.71,0l-.56-.56a1.522,1.522,0,0,0-2.12,0l-1.92,1.92Zm15.87,12.88a1.5,1.5,0,0,1-1.5,1.5H5.565a1.5,1.5,0,0,1-1.5-1.5v-.75L6.7,15.06a.5.5,0,0,1,.35-.14.524.524,0,0,1,.36.14l.55.56a1.509,1.509,0,0,0,2.12,0l4.57-4.57a.5.5,0,0,1,.71,0l4.58,4.58Z"/><path d="M8.062,10.565a2.5,2.5,0,1,1,2.5-2.5A2.5,2.5,0,0,1,8.062,10.565Zm0-4a1.5,1.5,0,1,0,1.5,1.5A1.5,1.5,0,0,0,8.062,6.565Z"/></svg>',
          animation: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="4" width="20" height="16" rx="3"/><path d="M2 9h20M2 15h20M7 4v16M12 4v16M17 4v16"/><path d="M10 11.5l4 2.5-4 2.5z" fill="currentColor" stroke="none"/></svg>'
        };
        const icon = icons[node.type] || icons.renderer;

        const titles = { source: 'Source', renderer: 'Renderer', animation: 'Animation' };
        const title = titles[node.type] || node.type;
        const hasImage = !!node.thumbnail;

        // 미니툴바 HTML - 렌더 완료된 카드만 Animation 버튼 표시
        const showAnimation = node.type === 'renderer' && hasImage;
        const animBtn = showAnimation ? `
            <button class="node-mini-toolbar-btn" data-add="animation" title="Add Animation">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="4" width="20" height="16" rx="3"/><path d="M2 9h20"/><path d="M7 4v5M12 4v5M17 4v5"/><path d="M10 14l5 3-5 3z" fill="currentColor" stroke="none"/></svg>
            </button>` : '';
        const miniToolbar = `
          <div class="node-mini-toolbar">
            <button class="node-mini-toolbar-btn" data-add="source" title="Add Source">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="4" y="3" width="14" height="18" rx="2"/><rect x="7" y="6" width="8" height="5" rx="1"/><line x1="7" y1="14" x2="15" y2="14"/><line x1="7" y1="17" x2="12" y2="17"/><circle cx="17" cy="18" r="4.5" fill="#1c2128" stroke="currentColor" stroke-width="1.5"/><line x1="17" y1="16" x2="17" y2="20"/><line x1="15" y1="18" x2="19" y2="18"/></svg>
            </button>
            <button class="node-mini-toolbar-btn" data-add="renderer" title="Add Renderer">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="3" y="3" width="18" height="18" rx="3"/><circle cx="8.5" cy="10" r="2"/><path d="M3 17l4.5-4.5a1.5 1.5 0 0 1 2.1 0l3.9 3.9"/><path d="M14 15l1.5-1.5a1.5 1.5 0 0 1 2.1 0L21 17"/><path d="M17 3l2 2.5L17 8" stroke-width="1.5" fill="none"/></svg>
            </button>${animBtn}
          </div>`;

        if (hasImage) {
          const existingImg = el.querySelector('.node-thumbnail img');
          if (existingImg && el._hasImage) {
            existingImg.src = 'data:image/png;base64,' + node.thumbnail;
            return;
          }
          el._hasImage = true;
          el.innerHTML = `${miniToolbar}
            <div class="node-thumbnail" style="border-radius:6px;">
              <img src="data:image/png;base64,${node.thumbnail}">
            </div>
            <div class="node-ports">
              ${node.type === 'source' ? '<div></div>' : '<div class="node-port node-port-input" data-port="input"></div>'}
              <div class="node-port node-port-output" data-port="output"></div>
            </div>
            <div class="node-progress"><div class="node-progress-bar"></div></div>
            <div class="node-label-outside">
              <div class="node-title">${title}</div>
            </div>
          `;
        } else {
          el._hasImage = false;
          el.innerHTML = `${miniToolbar}
            <div class="node-thumbnail">
              <div class="node-header-icon">${icon}</div>
            </div>
            <div class="node-ports">
              ${node.type === 'source' ? '<div></div>' : '<div class="node-port node-port-input" data-port="input"></div>'}
              <div class="node-port node-port-output" data-port="output"></div>
            </div>
            <div class="node-progress"><div class="node-progress-bar"></div></div>
            <div class="node-label-outside">
              <div class="node-title">${title}</div>
            </div>
          `;
        }

        // 포트 이벤트
        el.querySelectorAll('.node-port').forEach(port => {
          port.addEventListener('mousedown', (e) => {
            e.stopPropagation();
            this.startConnect(node.id, port.dataset.port);
          });
          port.addEventListener('mouseup', (e) => {
            e.stopPropagation();
            this.endConnect(node.id, port.dataset.port);
          });
        });

        // 미니툴바 버튼 이벤트
        el.querySelectorAll('.node-mini-toolbar-btn').forEach(btn => {
          btn.addEventListener('mousedown', (e) => e.stopPropagation());
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const addType = btn.dataset.add;
            this.addNodeBelow(node, addType);
          });
        });
      },

      // 노드 선택 (CSS 클래스만 토글, innerHTML 재생성 안함)
      selectNode: function(nodeId) {
        const prevId = this.selectedNode;
        this.selectedNode = nodeId;
        // 이전 선택 해제
        if (prevId) {
          const prevEl = document.getElementById('node-' + prevId);
          if (prevEl) prevEl.classList.remove('selected');
        }
        // 새 선택 적용
        if (nodeId) {
          const newEl = document.getElementById('node-' + nodeId);
          if (newEl) newEl.classList.add('selected');
        }
        this.updateInspector();
      },

      // Inspector 업데이트
      updateInspector: function() {
        const emptyEl = document.getElementById('node-inspector-empty');
        const sourceEl = document.getElementById('inspector-source');
        const rendererEl = document.getElementById('inspector-renderer');
        const previewEl = document.getElementById('node-preview-image');
        const bottomPrompt = document.getElementById('node-prompt-input');

        emptyEl.classList.add('hidden');
        sourceEl.classList.add('hidden');
        rendererEl.classList.add('hidden');

        if (!this.selectedNode) {
          emptyEl.classList.remove('hidden');
          previewEl.innerHTML = '<span class="node-inspector-preview-empty">No preview</span>';
          bottomPrompt.value = '';
          bottomPrompt.placeholder = 'Select a renderer node...';
          return;
        }

        const node = this.nodes.find(n => n.id === this.selectedNode);
        if (!node) {
          emptyEl.classList.remove('hidden');
          previewEl.innerHTML = '<span class="node-inspector-preview-empty">No preview</span>';
          return;
        }

        // Preview 이미지 업데이트
        if (node.data.image) {
          previewEl.innerHTML = '<img src="data:image/png;base64,' + node.data.image + '" alt="Preview">';
        } else {
          previewEl.innerHTML = '<span class="node-inspector-preview-empty">No preview</span>';
        }

        if (node.type === 'source') {
          sourceEl.classList.remove('hidden');
          // Time 버튼 상태
          sourceEl.querySelectorAll('[data-time]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.time === node.data.time);
          });
          // Light 버튼 상태
          sourceEl.querySelectorAll('[data-light]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.light === node.data.light);
          });
          bottomPrompt.placeholder = 'Select a renderer node to edit prompt...';
          bottomPrompt.value = '';
        } else if (node.type === 'renderer') {
          rendererEl.classList.remove('hidden');
          // Resolution 버튼 상태
          rendererEl.querySelectorAll('[data-res]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.res === node.data.resolution);
          });
          // Aspect 버튼 상태
          rendererEl.querySelectorAll('[data-aspect]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.aspect === node.data.aspect);
          });
          // Presets 버튼 상태
          rendererEl.querySelectorAll('[data-preset]').forEach(btn => {
            btn.classList.toggle('active', node.data.presets.includes(btn.dataset.preset));
          });
          // Custom prompt - Inspector와 하단 바 동기화
          const customPrompt = node.data.customPrompt || '';
          document.getElementById('node-custom-prompt').value = customPrompt;
          bottomPrompt.value = customPrompt;
          bottomPrompt.placeholder = 'Enter prompt or select presets above...';
        }
      },

      // 드래그 시작
      onNodeMouseDown: function(e, node) {
        if (e.target.classList.contains('node-port')) return;
        this.draggingNode = node;
        this.dragOffset = {
          x: e.clientX - node.x,
          y: e.clientY - node.y
        };
        e.preventDefault();
      },

      // 연결 시작
      startConnect: function(nodeId, portType) {
        if (portType === 'output') {
          this.connecting = { fromId: nodeId, fromPort: 'output' };
        }
      },

      // 연결 끝
      endConnect: function(nodeId, portType) {
        if (this.connecting && portType === 'input' && this.connecting.fromId !== nodeId) {
          this.connect(this.connecting.fromId, nodeId);
        }
        this.connecting = null;
      },

      // 연결 생성
      connect: function(fromId, toId) {
        // 중복 체크
        const exists = this.connections.some(c => c.from === fromId && c.to === toId);
        if (exists) return;

        // 기존 입력 연결 제거 (하나의 입력만 허용)
        this.connections = this.connections.filter(c => c.to !== toId);

        this.connections.push({ from: fromId, to: toId });
        this.renderConnections();
        this.markDirty();

        // 연결된 포트 표시
        this.nodes.forEach(n => this.renderNode(n));
      },

      // 연결선 렌더링 (노드 좌표 기반으로 직접 계산 - getBoundingClientRect 회피)
      renderConnections: function() {
        const svg = document.getElementById('node-connections');
        const nodeWidth = 320;

        // SVG path 재사용 (DOM 노드 생성 최소화)
        const existingPaths = svg.querySelectorAll('path');
        let pathIndex = 0;

        this.connections.forEach(conn => {
          const fromNode = this.nodes.find(n => n.id === conn.from);
          const toNode = this.nodes.find(n => n.id === conn.to);
          if (!fromNode || !toNode) return;

          // 포트 위치를 노드 좌표에서 직접 계산 (리플로우 없음)
          // output 포트: 노드 오른쪽 중간 아래
          const fromEl = document.getElementById('node-' + fromNode.id);
          const toEl = document.getElementById('node-' + toNode.id);
          if (!fromEl || !toEl) return;

          const fromH = fromEl.offsetHeight || 200;
          const toH = toEl.offsetHeight || 200;

          const x1 = fromNode.x + nodeWidth;
          const y1 = fromNode.y + fromH * 0.45;
          const x2 = toNode.x;
          const y2 = toNode.y + toH * 0.45;

          const d = `M ${x1} ${y1} C ${(x1+x2)/2} ${y1}, ${(x1+x2)/2} ${y2}, ${x2} ${y2}`;

          let path;
          if (pathIndex < existingPaths.length) {
            path = existingPaths[pathIndex];
            path.setAttribute('d', d);
          } else {
            path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('class', 'node-connection');
            path.setAttribute('d', d);
            svg.appendChild(path);
          }
          pathIndex++;
        });

        // 남은 path 제거
        while (pathIndex < existingPaths.length) {
          existingPaths[pathIndex].remove();
          pathIndex++;
        }
      },

      // Dirty 표시
      markDirty: function() {
        this.dirty = true;
        document.getElementById('node-make-btn').disabled = false;
      },

      // 노드 삭제
      deleteNode: function(nodeId) {
        this.nodes = this.nodes.filter(n => n.id !== nodeId);
        this.connections = this.connections.filter(c => c.from !== nodeId && c.to !== nodeId);
        const el = document.getElementById('node-' + nodeId);
        if (el) el.remove();
        this.renderConnections();
        if (this.selectedNode === nodeId) {
          this.selectedNode = null;
          this.updateInspector();
        }
      },

      // Make 실행
      execute: async function() {
        if (!this.dirty) return;

        const makeBtn = document.getElementById('node-make-btn');
        makeBtn.disabled = true;
        makeBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;animation:spin 1s linear infinite;"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg> Processing...';

        // Topological sort로 실행 순서 결정
        const sorted = this.topologicalSort();

        for (const nodeId of sorted) {
          const node = this.nodes.find(n => n.id === nodeId);
          if (!node) continue;

          const el = document.getElementById('node-' + node.id);
          if (el) el.classList.add('processing');

          if (node.type === 'source') {
            // Source 노드: 캡처 실행
            await this.executeSourceNode(node);
          } else if (node.type === 'renderer') {
            // Renderer 노드: 렌더링 실행
            await this.executeRendererNode(node);
          }

          node.dirty = false;
          if (el) el.classList.remove('processing');
          this.renderNode(node);
        }

        this.dirty = false;
        makeBtn.disabled = false;
        makeBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="currentColor" style="width:16px;height:16px;"><path d="M13 10V3L4 14h7v7l9-11h-7z"/></svg> Make';
      },

      // Source 노드 실행
      executeSourceNode: async function(node) {
        const self = this;
        return new Promise((resolve) => {
          // 캡처 요청
          window._nodeSourceCallback = (imageBase64) => {
            node.data.image = imageBase64;
            node.thumbnail = imageBase64;
            node.dirty = false;
            self.renderNode(node);
            self.updateInspector();
            resolve();
          };
          sketchup.captureScene(state.imageSize);
          // 타임아웃 fallback
          setTimeout(() => {
            if (window._nodeSourceCallback) {
              resolve();
            }
          }, 10000);
        });
      },

      // Renderer 노드 실행
      executeRendererNode: async function(node) {
        // 입력 연결 찾기
        const inputConn = this.connections.find(c => c.to === node.id);
        if (!inputConn) return;

        const sourceNode = this.nodes.find(n => n.id === inputConn.from);
        if (!sourceNode || !sourceNode.data.image) return;

        return new Promise((resolve) => {
          window._nodeRendererCallback = (imageBase64) => {
            node.thumbnail = imageBase64;
            this.renderNode(node);
            resolve();
          };

          // 프롬프트 조합
          let prompt = node.data.customPrompt || 'Create photorealistic interior render';
          if (node.data.presets.length > 0) {
            prompt += '. Style: ' + node.data.presets.join(', ');
          }

          // 렌더링 요청
          sketchup.startRender(
            sourceNode.data.time,
            sourceNode.data.light,
            prompt,
            ''
          );

          // 타임아웃 fallback
          setTimeout(() => {
            if (window._nodeRendererCallback) {
              resolve();
            }
          }, 120000);
        });
      },

      // Topological Sort
      topologicalSort: function() {
        const result = [];
        const visited = new Set();
        const nodeMap = new Map(this.nodes.map(n => [n.id, n]));

        const visit = (nodeId) => {
          if (visited.has(nodeId)) return;
          visited.add(nodeId);

          // 입력 노드들 먼저 방문
          this.connections
            .filter(c => c.to === nodeId)
            .forEach(c => visit(c.from));

          result.push(nodeId);
        };

        this.nodes.forEach(n => visit(n.id));
        return result;
      }
    };

    // Node Editor 이벤트
    document.getElementById('node-canvas-area').addEventListener('click', (e) => {
      if (e.target.id === 'node-canvas-area' || e.target.classList.contains('node-canvas-grid')) {
        nodeEditor.selectNode(null);
      }
    });

    // 드래그 mousemove - requestAnimationFrame으로 throttle + positionOnly 렌더링
    let _dragRafId = null;
    document.addEventListener('mousemove', (e) => {
      if (!nodeEditor.draggingNode) return;
      const nx = e.clientX - nodeEditor.dragOffset.x;
      const ny = e.clientY - nodeEditor.dragOffset.y;
      nodeEditor.draggingNode.x = nx;
      nodeEditor.draggingNode.y = ny;
      if (!_dragRafId) {
        _dragRafId = requestAnimationFrame(() => {
          nodeEditor.renderNode(nodeEditor.draggingNode, true);
          nodeEditor.renderConnections();
          _dragRafId = null;
        });
      }
    });

    document.addEventListener('mouseup', () => {
      if (_dragRafId) { cancelAnimationFrame(_dragRafId); _dragRafId = null; }
      nodeEditor.draggingNode = null;
      nodeEditor.connecting = null;
    });

    // 툴바 버튼
    document.getElementById('node-add-source').addEventListener('click', () => {
      nodeEditor.addNode('source', 100 + Math.random() * 100, 100 + Math.random() * 100);
    });

    document.getElementById('node-add-renderer').addEventListener('click', () => {
      nodeEditor.addNode('renderer', 400 + Math.random() * 100, 100 + Math.random() * 100);
    });

    document.getElementById('node-delete').addEventListener('click', () => {
      if (nodeEditor.selectedNode) {
        nodeEditor.deleteNode(nodeEditor.selectedNode);
      }
    });

    document.getElementById('node-make-btn').addEventListener('click', () => {
      nodeEditor.execute();
    });

    // Inspector 이벤트 - Source
    document.getElementById('inspector-source').addEventListener('click', (e) => {
      const btn = e.target.closest('[data-time], [data-light]');
      if (!btn) return;

      const node = nodeEditor.nodes.find(n => n.id === nodeEditor.selectedNode);
      if (!node) return;

      if (btn.dataset.time) {
        node.data.time = btn.dataset.time;
        node.dirty = true;
      }
      if (btn.dataset.light) {
        node.data.light = btn.dataset.light;
        node.dirty = true;
      }

      nodeEditor.markDirty();
      nodeEditor.renderNode(node);
      nodeEditor.updateInspector();
    });

    document.getElementById('node-source-capture').addEventListener('click', () => {
      const node = nodeEditor.nodes.find(n => n.id === nodeEditor.selectedNode);
      if (node && node.type === 'source') {
        nodeEditor.executeSourceNode(node);
      }
    });

    // Inspector 이벤트 - Renderer
    document.getElementById('inspector-renderer').addEventListener('click', (e) => {
      const btn = e.target.closest('[data-res], [data-aspect], [data-preset]');
      if (!btn) return;

      const node = nodeEditor.nodes.find(n => n.id === nodeEditor.selectedNode);
      if (!node) return;

      if (btn.dataset.res) {
        node.data.resolution = btn.dataset.res;
        node.dirty = true;
      }
      if (btn.dataset.aspect) {
        node.data.aspect = btn.dataset.aspect;
        node.dirty = true;
      }
      if (btn.dataset.preset) {
        const idx = node.data.presets.indexOf(btn.dataset.preset);
        if (idx >= 0) {
          node.data.presets.splice(idx, 1);
        } else {
          node.data.presets.push(btn.dataset.preset);
        }
        node.dirty = true;
      }

      nodeEditor.markDirty();
      nodeEditor.renderNode(node);
      nodeEditor.updateInspector();
    });

    document.getElementById('node-custom-prompt').addEventListener('input', (e) => {
      const node = nodeEditor.nodes.find(n => n.id === nodeEditor.selectedNode);
      if (node && node.type === 'renderer') {
        node.data.customPrompt = e.target.value;
        node.dirty = true;
        nodeEditor.markDirty();
        nodeEditor.renderNode(node);
      }
    });

    // 아코디언 토글 이벤트
    document.querySelectorAll('.node-inspector-accordion-header').forEach(header => {
      header.addEventListener('click', () => {
        header.parentElement.classList.toggle('open');
      });
    });

    // Inspector 탭 이벤트
    document.querySelectorAll('.node-inspector-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.node-inspector-tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        // TODO: 탭별 컨텐츠 전환 (preview/compare)
      });
    });

    // 하단 프롬프트 바 입력 연동
    document.getElementById('node-prompt-input').addEventListener('input', (e) => {
      const node = nodeEditor.nodes.find(n => n.id === nodeEditor.selectedNode && n.type === 'renderer');
      if (node) {
        node.data.customPrompt = e.target.value;
        document.getElementById('node-custom-prompt').value = e.target.value;
        node.dirty = true;
        nodeEditor.markDirty();
      }
    });

  </script>
</body>
</html>
